[
    {
        "problem_type": "dense_la",
        "language": "cpp",
        "name": "01_dense_la_solve",
        "parallelism_model": "serial",
        "prompt": "/* Solve the linear system Ax=b for x.\n   A is an NxN matrix in row-major. x and b have N elements.\n   Example:\n   \n   input: A=[[1,4,2], [1,2,3], [2,1,3]] b=[11, 11, 13]\n   output: x=[3, 1, 2]\n*/\nvoid solveLinearSystem(std::vector<double> const& A, std::vector<double> const& b, std::vector<double> &x, size_t N) {",
        "src_code": "#pragma once\n#include <vector>\n\n/* Solve the linear system Ax=b for x.\n   A is an NxN matrix in row-major. x and b have N elements.\n   Example:\n   \n   input: A=[[1,4,2], [1,2,3], [2,1,3]] b=[11, 11, 13]\n   output: x=[3, 1, 2]\n*/\nvoid NO_INLINE solveLinearSystem(std::vector<double> const& A, std::vector<double> const& b, std::vector<double> &x, size_t N) {\n   // Create a copy of A to perform Gaussian elimination\n   std::vector<double> A_copy = A;\n   std::vector<double> b_copy = b;\n\n   // Gaussian elimination\n   for (size_t i = 0; i < N - 1; i++) {\n      // Find the pivot element\n      double pivot = A_copy[i * N + i];\n\n      // Check if the pivot is zero\n      if (pivot == 0) {\n         return;\n      }\n\n      // Eliminate the elements below the pivot\n      for (size_t j = i + 1; j < N; j++) {\n         double factor = A_copy[j * N + i] / pivot;\n         for (size_t k = i; k < N; k++) {\n            A_copy[j * N + k] -= factor * A_copy[i * N + k];\n         }\n         b_copy[j] -= factor * b_copy[i];\n      }\n   }\n\n   // Back substitution\n   for (int i = N - 1; i >= 0; i--) {\n      double sum = 0;\n      for (size_t j = i + 1; j < N; j++) {\n         sum += A_copy[i * N + j] * x[j];\n      }\n      x[i] = (b_copy[i] - sum) / A_copy[i * N + i];\n   }\n}"
    },
    {
        "problem_type": "fft",
        "language": "cpp",
        "name": "09_fft_fft_out_of_place",
        "parallelism_model": "serial",
        "prompt": "/* Compute the fourier transform of x. Store the result in output.\n   Example:\n\n   input: [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]\n   output: [{4,0}, {1,-2.42421}, {0,0}, {1,-0.414214}, {0,0}, {1,0.414214}, {0,0}, {1,2.41421}]\n*/\nvoid fft(std::vector<std::complex<double>> const& x, std::vector<std::complex<double>> &output) {",
        "src_code": "#pragma once\n#include <vector>\n#include <cmath>\n#include <complex>\n\n#if !defined(M_PI)\n#define M_PI 3.14159265358979323846\n#endif\n\n/* Compute the fourier transform of x. Store the result in output.\n   Example:\n\n   input: [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]\n   output: [{4,0}, {1,-2.42421}, {0,0}, {1,-0.414214}, {0,0}, {1,0.414214}, {0,0}, {1,2.41421}]\n*/\nvoid NO_INLINE fft(std::vector<std::complex<double>> const& x, std::vector<std::complex<double>> &output) {\n   output = x;\n\n   // DFT\n\tunsigned int N = output.size(), k = N, n;\n\tdouble thetaT = 3.14159265358979323846264338328L / N;\n\tstd::complex<double> phiT = std::complex<double>(std::cos(thetaT), -std::sin(thetaT)), T;\n\twhile (k > 1) {\n\t\tn = k;\n\t\tk >>= 1;\n\t\tphiT = phiT * phiT;\n\t\tT = 1.0L;\n\t\tfor (unsigned int l = 0; l < k; l++)\n\t\t{\n\t\t\tfor (unsigned int a = l; a < N; a += n)\n\t\t\t{\n\t\t\t\tunsigned int b = a + k;\n\t\t\t\tstd::complex<double> t = output[a] - output[b];\n\t\t\t\toutput[a] += output[b];\n\t\t\t\toutput[b] = t * T;\n\t\t\t}\n\t\t\tT *= phiT;\n\t\t}\n\t}\n\t// Decimate\n\tunsigned int m = (unsigned int)std::log2(N);\n\tfor (unsigned int a = 0; a < N; a++) {\n\t\tunsigned int b = a;\n\t\t// Reverse bits\n\t\tb = (((b & 0xaaaaaaaa) >> 1) | ((b & 0x55555555) << 1));\n\t\tb = (((b & 0xcccccccc) >> 2) | ((b & 0x33333333) << 2));\n\t\tb = (((b & 0xf0f0f0f0) >> 4) | ((b & 0x0f0f0f0f) << 4));\n\t\tb = (((b & 0xff00ff00) >> 8) | ((b & 0x00ff00ff) << 8));\n\t\tb = ((b >> 16) | (b << 16)) >> (32 - m);\n\t\tif (b > a) {\n\t\t\tstd::complex<double> t = output[a];\n\t\t\toutput[a] = output[b];\n\t\t\toutput[b] = t;\n\t\t}\n\t}\n}\n\n#if defined(USE_CUDA)\n// a lot of model outputs assume this is defined for some reason, so just define it\n__device__ DOUBLE_COMPLEX_T cexp(DOUBLE_COMPLEX_T arg) {\n   DOUBLE_COMPLEX_T res;\n   float s, c;\n   float e = expf(arg.x);\n   sincosf(arg.y, &s, &c);\n   res.x = c * e;\n   res.y = s * e;\n   return res;\n}\n\n__device__ DOUBLE_COMPLEX_T cuCexp(DOUBLE_COMPLEX_T arg) {\n   return cexp(arg);\n}\n\n__device__ DOUBLE_COMPLEX_T hipCexp(DOUBLE_COMPLEX_T arg) {\n   return cexp(arg);\n}\n#endif"
    },
    {
        "problem_type": "geometry",
        "language": "cpp",
        "name": "14_geometry_closest_pair_1d",
        "parallelism_model": "serial",
        "prompt": "double distance(double x1, double x2) {\n\treturn std::abs(x1 - x2);\n}\n\n/* Return the distance between the closest two elements in the vector x.\n   Example: \n\n   input: [7, 3, 9, 12, 31, 1]\n   output: 2\n*/\ndouble closestPair(std::vector<double> const& x) {",
        "src_code": "#pragma once\n#include <vector>\n#include <limits>\n\n/* Return the distance between the closest two elements in the vector x.\n   Example:\n\n   input: [7, 3, 9, 12, 31, 1]\n   output: 2\n*/\ndouble NO_INLINE closestPair(std::vector<double> const& x) {\n    // The vector needs to have at least two elements\n    if (x.size() < 2)   {\n        return 0;\n    }\n\n    auto getDist = [](double const& a, double const& b) {\n        return std::abs(b-a);\n    };\n\n    double minDist = std::numeric_limits<double>::max();\n    for (size_t i = 0; i < x.size() - 1; i++) {\n        for (size_t j = i + 1; j < x.size(); j++) {\n            const double dist = getDist(x[i], x[j]);\n            if (dist < minDist) {\n                minDist = dist;\n            }\n        }\n    }\n\n    return minDist;\n}\n"
    },
    {
        "problem_type": "graph",
        "language": "cpp",
        "name": "19_graph_shortest_path",
        "parallelism_model": "serial",
        "prompt": "/* Return the length of the shortest path from source to dest in the undirected graph defined by the adjacency matrix A.\n   A is an NxN adjacency matrix stored in row-major. A is an undirected graph.\n   Example:\n\n\t input: [[0, 1, 1, 0], [1, 0, 0, 1], [1, 0, 0, 1], [0, 1, 1, 0]], source=0, dest=3\n   output: 2\n*/\nint shortestPathLength(std::vector<int> const& A, size_t N, int source, int dest) {",
        "src_code": "#pragma once\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <limits>\n#include <climits>\n\n/* Return the length of the shortest path from source to dest in the undirected graph defined by the adjacency matrix A.\n   A is an NxN adjacency matrix stored in row-major. Assume the graph is connected. A is undirected.\n   Example:\n   \n   input: [[0, 1, 1, 0], [1, 0, 0, 1], [1, 0, 0, 1], [0, 1, 1, 0]], source=0, dest=3\n   output: 2\n*/\nint NO_INLINE shortestPathLength(std::vector<int> const& A, size_t N, int source, int dest) {\n   std::vector<bool> visited(N, false);\n   std::queue<std::pair<int, int>> queue;\n   visited[source] = true;\n   queue.push({source, 0});\n\n   while (!queue.empty()) {\n      auto [current, pathLength] = queue.front();\n      queue.pop();\n\n      if (current == dest) {\n         return pathLength;\n      }\n\n      // Check all adjacent vertices\n      for (int i = 0; i < N; ++i) {\n         if (A[current*N + i] && !visited[i]) {\n               visited[i] = true;\n               queue.push({i, pathLength + 1});\n         }\n      }\n   }\n\n   return std::numeric_limits<int>::max();\n}\n"
    },
    {
        "problem_type": "histogram",
        "language": "cpp",
        "name": "22_histogram_count_quadrants",
        "parallelism_model": "serial",
        "prompt": "struct Point {\n   double x, y;\n};\n\n/* Count the number of cartesian points in each quadrant. The vector points contains a list of `Point` objects.\n   Store the counts in `bins`.\n   Example:\n\n   input: [{x=1.5, y=0.1}, {x=-3, y=1.1}, {x=5, y=9}, {x=1.5, y=-1}, {x=3, y=-7}, {x=0.1, y=2}]\n   output: [3, 1, 0, 2]\n*/\nvoid countQuadrants(std::vector<Point> const& points, std::array<size_t, 4> &bins) {",
        "src_code": "#pragma once\n#include <array>\n#include <vector>\n\nstruct Point {\n  double x, y;\n};\n\n/* Count the number of cartesian points in each quadrant. The vector points contains a list of `Point` objects.\n   Store the counts in `bins`.\n   Example:\n\n   input: [{x=1.5, y=0.1}, {x=-3, y=1.1}, {x=5, y=9}, {x=1.5, y=-1}, {x=3, y=-7}, {x=0.1, y=2}]\n   output: [3, 1, 0, 2]\n*/\nvoid NO_INLINE countQuadrants(std::vector<Point> const& points, std::array<size_t, 4> &bins) {\n   for (auto const& point : points) {\n      if (point.x >= 0 && point.y >= 0) {\n            bins[0] += 1;\n      } else if (point.x < 0 && point.y >= 0) {\n            bins[1] += 1;\n      } else if (point.x < 0 && point.y < 0) {\n            bins[2] += 1;\n      } else if (point.x >= 0 && point.y < 0) {\n            bins[3] += 1;\n      }\n   }\n}"
    },
    {
        "problem_type": "reduce",
        "language": "cpp",
        "name": "27_reduce_average",
        "parallelism_model": "serial",
        "prompt": "/* Return the average of the vector x.\n   Examples:\n\t\t\n\t input: [1, 8, 4, 5, 1]\n   output: 3.8\n\n   input: [2, 2, 2, 3]\n   output: 2.25\n*/\ndouble average(std::vector<double> const& x) {",
        "src_code": "#pragma once\n#include <vector>\n#include <numeric>\n\n/* Return the average of the vector x.\n   Examples:\n\n   input: [1, 8, 4, 5, 1]\n   output: 3.8\n\n   input: [2, 2, 2, 3]\n   output: 2.25\n*/\ndouble NO_INLINE average(std::vector<double> const& x) {\n    return std::reduce(x.begin(), x.end(), 0.0) / (double) x.size();\n}\n"
    },
    {
        "problem_type": "scan",
        "language": "cpp",
        "name": "31_scan_scan_with_min_function",
        "parallelism_model": "serial",
        "prompt": "/* Replace the i-th element of the vector x with the minimum value from indices 0 through i.\n   Examples:\n\n   input: [8, 6, -1, 7, 3, 4, 4]\n   output: [8, 6, -1, -1, -1, -1, -1]\n\n   input: [5, 4, 6, 4, 3, 6, 1, 1]\n   output: [5, 4, 4, 4, 3, 3, 1, 1]\n*/\nvoid partialMinimums(std::vector<float> &x) {",
        "src_code": "#pragma once\n\n#include <numeric>\n#include <vector>\n\n/* Replace the i-th element of the vector x with the minimum value from indices 0 through i.\n   Examples:\n\n   input: [8, 6, -1, 7, 3, 4, 4]\n   output: [8, 6, -1, -1, -1, -1, -1]\n\n   input: [5, 4, 6, 4, 3, 6, 1, 1]\n   output: [5, 4, 4, 4, 3, 3, 1, 1]\n*/\nvoid NO_INLINE partialMinimums(std::vector<float> &x) {\n    std::inclusive_scan(x.begin(), x.end(), x.begin(), [] (const float &x, const float &y) {\n                                                           return std::min(x, y);\n                                                       },\n        std::numeric_limits<float>::max());\n}\n"
    },
    {
        "problem_type": "search",
        "language": "cpp",
        "name": "36_search_check_if_array_contains_value",
        "parallelism_model": "serial",
        "prompt": "/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Examples:\n\n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {",
        "src_code": "#pragma once\n#include <vector>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Examples:\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n\n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool NO_INLINE contains(std::vector<int> const& x, int target) {\n    return std::find(x.begin(), x.end(), target) != x.end();\n}"
    },
    {
        "problem_type": "sort",
        "language": "cpp",
        "name": "41_sort_k-th_smallest_element",
        "parallelism_model": "serial",
        "prompt": "/* Find the k-th smallest element of the vector x.\n   Example:\n   \n   input: x=[1, 7, 6, 0, 2, 2, 10, 6], k=4\n   output: 6\n*/\nint findKthSmallest(std::vector<int> const& x, int k) {",
        "src_code": "#pragma once\n#include <algorithm>\n#include <vector>\n\n/* Find the k-th smallest element of the vector x.\n   Example:\n   \n   input: x=[1, 7, 6, 0, 2, 2, 10, 6], k=4\n   output: 6\n*/\nint NO_INLINE findKthSmallest(std::vector<int> const& x, int k) {\n   std::vector<int> x_copy = x;\n   std::sort(x_copy.begin(), x_copy.end());\n   return x_copy[k-1];\n}"
    },
    {
        "problem_type": "sparse_la",
        "language": "cpp",
        "name": "47_sparse_la_spmv",
        "parallelism_model": "serial",
        "prompt": "struct COOElement {\n   size_t row, column;\n   double value;\n};\n\n/* Compute y = alpha*A*x + beta*y where alpha and beta are scalars, x and y are vectors,\n   and A is a sparse matrix stored in COO format.\n   A has dimensions MxN, x has N values, and y has M values.\n   Example:\n\n   input: alpha=0.5 beta=1.0 A=[{0,1,3}, {1,0,-1}] x=[-4, 2] y=[-1,1]\n   output: y=[2, 3]\n*/\nvoid spmv(double alpha, std::vector<COOElement> const& A, std::vector<double> const& x, double beta, std::vector<double> &y, size_t M, size_t N) {",
        "src_code": "#pragma once\n#include <vector>\n\nstruct COOElement {\n   size_t row, column;\n   double value;\n};\n\n/* Compute y = alpha*A*x + beta*y where alpha and beta are scalars, x and y are vectors,\n   and A is a sparse matrix stored in COO format.\n   x and y are length N and A is M x N.\n   Example:\n\n   input: alpha=0.5 beta=1.0 A=[{0,1,3}, {1,0,-1}] x=[-4, 2] y=[-1,1]\n   output: y=[2, 3]\n*/\nvoid NO_INLINE spmv(double alpha, std::vector<COOElement> const& A, std::vector<double> const& x, double beta, std::vector<double> &y, size_t M, size_t N) {\n   for (auto& element : y) {\n      element *= beta;\n   }\n   \n   for (const auto& a_ij : A) {\n      if (a_ij.row < M && a_ij.column < N) {\n         y[a_ij.row] += alpha * a_ij.value * x[a_ij.column];\n      }\n   }\n}"
    },
    {
        "problem_type": "stencil",
        "language": "cpp",
        "name": "50_stencil_xor_kernel",
        "parallelism_model": "serial",
        "prompt": "/* Set every cell's value to 1 if it has exactly one neighbor that's a 1. Otherwise set it to 0.\n   Note that we only consider neighbors and not input_{i,j} when computing output_{i,j}.\n   input and output are NxN grids of ints in row-major.\n   Example:\n\n   input: [[0, 1, 1, 0],\n           [1, 0, 0, 0],\n           [0, 0, 0, 0],\n           [0, 1, 0, 0]\n   output: [[0, 0, 1, 1],\n            [1, 0, 0, 1],\n            [0, 0, 1, 0],\n            [1, 0, 1, 0]]\n*/\nvoid cellsXOR(std::vector<int> const& input, std::vector<int> &output, size_t N) {",
        "src_code": "#pragma once\n#include <vector>\n\n/* Set every cell's value to 1 if it has exactly one neighbor that's a 1. Otherwise set it to 0.\n   Note that we only consider neighbors and not input_{i,j} when computing output_{i,j}.\n   input and output are NxN grids of ints in row-major.\n   Example:\n\n   input: [[0, 1, 1, 0],\n           [1, 0, 0, 0],\n           [0, 0, 0, 0],\n           [0, 1, 0, 0]\n   output: [[0, 0, 1, 1],\n            [1, 0, 0, 1],\n            [0, 0, 1, 0],\n            [1, 0, 1, 0]]\n*/\nvoid NO_INLINE cellsXOR(std::vector<int> const& input, std::vector<int> &output, size_t N) {\n    for (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int count = 0;\n            if (i > 0 && input[(i-1)*N + j] == 1) ++count;\n            if (i < N-1 && input[(i+1)*N + j] == 1) ++count;\n            if (j > 0 && input[i*N + j-1] == 1) ++count;\n            if (j < N-1 && input[i*N + j+1] == 1) ++count;\n            output[i*N + j] = (count == 1) ? 1 : 0;\n        }\n    }\n}\n"
    },
    {
        "problem_type": "transform",
        "language": "cpp",
        "name": "55_transform_relu",
        "parallelism_model": "serial",
        "prompt": "/* Compute the ReLU function on every element of x. Elements less than zero become zero,\n   while elements greater than zero stay the same.\n   Example:\n\n   input: [-1.8, 24.0, 1.2, 0.0, -5.1, -0.2, 4.5]\n   output: [0, 24.0, 1.2, 0, 0, 0, 4.5]\n*/\nvoid relu(std::vector<double> &x) {",
        "src_code": "#pragma once\n#include <vector>\n\n/* Compute the ReLU function on every element of x. Elements less than zero become zero,\n   while elements greater than zero stay the same.\n   Example:\n\n   input: [-1.8, 24.0, 1.2, 0.0, -5.1, -0.2, 4.5]\n   output: [0, 24.0, 1.2, 0, 0, 0, 4.5]\n*/\nvoid NO_INLINE relu(std::vector<double> &x) {\n    std::transform(x.begin(), x.end(), x.begin(), [](double v) {\n        return std::max(0.0, v);\n    });\n}"
    },
    {
        "problem_type": "dense_la",
        "language": "cpp",
        "name": "60_dense_la_gemv",
        "parallelism_model": "serial",
        "prompt": "/* Multiply the matrix A by the vector x. Store the results in the vector y.\n   A is an MxN matrix stored in row-major, x has N elements, and y has M elements.\n   Example:\n\n   input: A=[[1, -1, 2], [0, -3, 1]] x=[2, 1, 0]\n   output: y=[1, -3]\n*/\nvoid gemv(std::vector<double> const& A, std::vector<double> const& x, std::vector<double> &y, size_t M, size_t N) {",
        "src_code": "#pragma once\n#include <vector>\n\n/* Multiply the matrix A by the vector x. Store the results in the vector y.\n   A is an MxN matrix stored in row-major, x has N elements, and y has M elements.\n   Example:\n\n   input: A=[[1, -1, 2], [0, -3, 1]] x=[2, 1, 0]\n   output: y=[1, -3]\n*/\nvoid NO_INLINE gemv(std::vector<double> const& A, std::vector<double> const& x, std::vector<double> &y, size_t M, size_t N) {\n   for (size_t i = 0; i < M; i++) {\n      y[i] = 0;\n      for (size_t j = 0; j < N; j++) {\n         y[i] += A[i * N + j] * x[j];\n      }\n   }\n}"
    },
    {
        "problem_type": "fft",
        "language": "cpp",
        "name": "61_fft_fft_out_of_place",
        "parallelism_model": "serial",
        "prompt": "/* Compute the fourier transform of x. Store the result in output.\n   Example:\n\n   input: [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]\n   output: [{4,0}, {1,-2.42421}, {0,0}, {1,-0.414214}, {0,0}, {1,0.414214}, {0,0}, {1,2.41421}]\n*/\nvoid fft(std::vector<std::complex<double>> const& x, std::vector<std::complex<double>> &output) {",
        "src_code": "#pragma once\n#include <vector>\n#include <cmath>\n#include <complex>\n\n#if !defined(M_PI)\n#define M_PI 3.14159265358979323846\n#endif\n\n/* Compute the fourier transform of x. Store the result in output.\n   Example:\n\n   input: [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]\n   output: [{4,0}, {1,-2.42421}, {0,0}, {1,-0.414214}, {0,0}, {1,0.414214}, {0,0}, {1,2.41421}]\n*/\nvoid NO_INLINE fft(std::vector<std::complex<double>> const& x, std::vector<std::complex<double>> &output) {\n   output = x;\n\n   // DFT\n\tunsigned int N = output.size(), k = N, n;\n\tdouble thetaT = 3.14159265358979323846264338328L / N;\n\tstd::complex<double> phiT = std::complex<double>(std::cos(thetaT), -std::sin(thetaT)), T;\n\twhile (k > 1) {\n\t\tn = k;\n\t\tk >>= 1;\n\t\tphiT = phiT * phiT;\n\t\tT = 1.0L;\n\t\tfor (unsigned int l = 0; l < k; l++)\n\t\t{\n\t\t\tfor (unsigned int a = l; a < N; a += n)\n\t\t\t{\n\t\t\t\tunsigned int b = a + k;\n\t\t\t\tstd::complex<double> t = output[a] - output[b];\n\t\t\t\toutput[a] += output[b];\n\t\t\t\toutput[b] = t * T;\n\t\t\t}\n\t\t\tT *= phiT;\n\t\t}\n\t}\n\t// Decimate\n\tunsigned int m = (unsigned int)std::log2(N);\n\tfor (unsigned int a = 0; a < N; a++) {\n\t\tunsigned int b = a;\n\t\t// Reverse bits\n\t\tb = (((b & 0xaaaaaaaa) >> 1) | ((b & 0x55555555) << 1));\n\t\tb = (((b & 0xcccccccc) >> 2) | ((b & 0x33333333) << 2));\n\t\tb = (((b & 0xf0f0f0f0) >> 4) | ((b & 0x0f0f0f0f) << 4));\n\t\tb = (((b & 0xff00ff00) >> 8) | ((b & 0x00ff00ff) << 8));\n\t\tb = ((b >> 16) | (b << 16)) >> (32 - m);\n\t\tif (b > a) {\n\t\t\tstd::complex<double> t = output[a];\n\t\t\toutput[a] = output[b];\n\t\t\toutput[b] = t;\n\t\t}\n\t}\n}\n\n\n#if defined(USE_CUDA)\n// a lot of model outputs assume this is defined for some reason, so just define it\n__device__ DOUBLE_COMPLEX_T cexp(DOUBLE_COMPLEX_T arg) {\n   DOUBLE_COMPLEX_T res;\n   float s, c;\n   float e = expf(arg.x);\n   sincosf(arg.y, &s, &c);\n   res.x = c * e;\n   res.y = s * e;\n   return res;\n}\n\n__device__ DOUBLE_COMPLEX_T cuCexp(DOUBLE_COMPLEX_T arg) {\n   return cexp(arg);\n}\n\n__device__ DOUBLE_COMPLEX_T hipCexp(DOUBLE_COMPLEX_T arg) {\n   return cexp(arg);\n}\n#endif\n"
    },
    {
        "problem_type": "geometry",
        "language": "cpp",
        "name": "62_geometry_farest_pair_1d",
        "parallelism_model": "serial",
        "prompt": "double distance(double x1, double x2) {\n\treturn std::abs(x1 - x2);\n}\n\n/* Return the distance between the farest two elements in the vector x.\n   Example: \n\n   input: [7, 3, 9, 12, 31, 1]\n   output: 2\n*/\ndouble farestPair(std::vector<double> const& x) {",
        "src_code": "#pragma once\n#include <vector>\n#include <limits>\n\n/* Return the distance between the farest two elements in the vector x.\n   Example:\n\n   input: [7, 3, 9, 12, 31, 1]\n   output: 30\n*/\ndouble NO_INLINE farestPair(std::vector<double> const& x) {\n    // The vector needs to have at least two elements\n    if (x.size() < 2)   {\n        return 0;\n    }\n\n    auto getDist = [](double const& a, double const& b) {\n        return std::abs(b-a);\n    };\n\n    double minDist = std::numeric_limits<double>::min();\n    for (size_t i = 0; i < x.size() - 1; i++) {\n        for (size_t j = i + 1; j < x.size(); j++) {\n            const double dist = getDist(x[i], x[j]);\n            if (dist > minDist) {\n                minDist = dist;\n            }\n        }\n    }\n\n    return minDist;\n}\n"
    },
    {
        "problem_type": "graph",
        "language": "cpp",
        "name": "63_graph_floyd",
        "parallelism_model": "serial",
        "prompt": "/* Return the length of the shortest path from any source to any dest in the undirected graph defined by the adjacency matrix A\nusing floyd algorithm.\n   A is an NxN adjacency matrix stored in row-major. Assume the graph is connected. A is undirected.\n   Example:\n   \n   input: [[0, 1, 1, 0], [1, 0, 0, 1], [1, 0, 0, 1], [0, 1, 1, 0]]\n   output: [[0, 1, 1, 2], [1, 0, 2, 1], [1, 2, 0, 1], [2, 1, 1, 0]]\n*/\nvoid floyd(std::vector<int> const& A, size_t N, std::vector<int>& R) {",
        "src_code": "#pragma once\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <limits>\n#include <climits>\n\n/* Return the length of the shortest path from any source to any dest in the undirected graph defined by the adjacency matrix A\nusing floyd algorithm.\n   A is an NxN adjacency matrix stored in row-major. Assume the graph is connected. A is undirected.\n   Example:\n   \n   input: [[0, 1, 1, 0], [1, 0, 0, 1], [1, 0, 0, 1], [0, 1, 1, 0]]\n   output: [[0, 1, 1, 2], [1, 0, 2, 1], [1, 2, 0, 1], [2, 1, 1, 0]]\n*/\nvoid NO_INLINE floyd(std::vector<int> const& A, size_t N, std::vector<int>& R) {\n    R = A;\n   for(int k=0; k<N; k++) {\n       for(int i=0; i<N; i++) {\n           for(int j=0; j<N; j++) {\n               R[i*N+j] = std::min(R[i*N+j], R[i*N+k]+R[k*N+j]);\n           }\n       }\n   }\n}\n"
    },
    {
        "problem_type": "histogram",
        "language": "cpp",
        "name": "64_histogram_count_odd_even",
        "parallelism_model": "serial",
        "prompt": "/* Count the number of odd and even numbers in a given integer vector x\n   Examples:\n\n   input: [7, 4, 3, 2, 1]\n   output: [3, 2]\n\n   input: [5, 3, 2 1]\n   output: [3, 1]\n*/\nvoid countOddEven(std::vector<int> const& x, std::array<size_t, 2> &bins) {",
        "src_code": "#pragma once\n#include <array>\n#include <vector>\n\n/* Count the number of odd and even numbers in a given integer vector x\n   Examples:\n\n   input: [7, 4, 3, 2, 1]\n   output: [3, 2]\n\n   input: [5, 3, 2 1]\n   output: [3, 1]\n*/\nvoid NO_INLINE countOddEven(std::vector<int> const& x, std::array<size_t, 2> &bins) {\n\n   bins[0] = bins[1] = 0;\n   for (int i = 0; i < x.size(); i += 1) {\n      if (x[i]%2==0) \tbins[1] += 1;\n      else    \t\tbins[0] += 1;\n   }\n}\n\n#if defined(USE_CUDA)\n// fix the issue where atomicAdd is not defined for size_t\nstatic_assert(sizeof(size_t) == sizeof(unsigned long long), \"size_t is not 64 bits\");\n\n__device__ __forceinline__ void atomicAdd(size_t* address, size_t val) {\n   atomicAdd(reinterpret_cast<unsigned long long*>(address), val);\n}\n#endif\n"
    },
    {
        "problem_type": "reduce",
        "language": "cpp",
        "name": "65_reduce_array_to_half",
        "parallelism_model": "serial",
        "prompt": "/* Given an integer array x. You can choose a set of integers and remove all the occurrences of these integers in the array.\n   Return the minimum size of the set so that at least half of the integers of the array are removed.\n\n   Example:\n\n   input: x=[[3, 3, 3, 3, 5, 5, 5, 2, 2, 7]\n   output: 2\n   explanation: Choosing {3,7} will make the new array [5,5,5,2,2] which has size 5 (i.e equal to half of the size of the old array).\nPossible sets of size 2 are {3,5},{3,2},{5,2}.\nChoosing set {2,7} is not possible as it will make the new array [3,3,3,3,5,5,5] which has a size greater than half of the size of the old array.\n\n   input: x = [7,7,7,7,7,7]\n   output: 1\n   explanation: The only possible set you can choose is {7}. This will make the new array empty.\n*/\nint reduceArrayToHalf(std::vector<int> const& x) {",
        "src_code": "#pragma once\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <unordered_map>\n#include <queue>\n/* Given an integer array x. You can choose a set of integers and remove all the occurrences of these integers in the array.\n   Return the minimum size of the set so that at least half of the integers of the array are removed.\n\n   Example:\n\n   input: x=[[3, 3, 3, 3, 5, 5, 5, 2, 2, 7]\n   output: 2\n   explanation: Choosing {3,7} will make the new array [5,5,5,2,2] which has size 5 (i.e equal to half of the size of the old array).\nPossible sets of size 2 are {3,5},{3,2},{5,2}.\nChoosing set {2,7} is not possible as it will make the new array [3,3,3,3,5,5,5] which has a size greater than half of the size of the old array.\n\n   input: x = [7,7,7,7,7,7]\n   output: 1\n   explanation: The only possible set you can choose is {7}. This will make the new array empty.\n*/\nint NO_INLINE reduceArrayToHalf(std::vector<int> const& x) {\n    std::unordered_map<int, int> counter;\n    std::priority_queue<int> q;\n    int res = 0, removed = 0;\n        \n    for (auto a : x) \t   counter[a]++;\n    for (auto c : counter) q.push(c.second);\n        \n    while (removed < x.size() / 2) {\n        removed += q.top();\n        q.pop();\n        res++;\n    }\n        \n    return res;\n}\n"
    },
    {
        "problem_type": "scan",
        "language": "cpp",
        "name": "66_scan_longest_increaseing_subarray",
        "parallelism_model": "serial",
        "prompt": "/* Return the first longest increasing contiguous subarray in the vector x.\n   i.e. if x=[\u22122, 1, 2, 0, \u22121, 2, 3, \u22125, 4] then [-2, 1, 2], [-1, 2, 3] are both longest increasing contiguous\n   subarray, but [-2, 1, 2] is the first one, thus we return [-2, 1, 2] as the result.\n   Example:\n\n   input: [\u22122, 1, 2, 0, \u22121, 2, 3, \u22125, 4]\n   output: [-2, 1, 2]\n*/\nvoid longestIncreasingSubarray(std::vector<int> const& x, std::vector<int> &output) {",
        "src_code": "#pragma once\n#include <vector>\n#include <limits>\n\n/* Return the first longest increasing contiguous subarray in the vector x.\n   i.e. if x=[\u22122, 1, 2, 0, \u22121, 2, 3, \u22125, 4] then [-2, 1, 2], [-1, 2, 3] are both longest increasing contiguous\n   subarray, but [-2, 1, 2] is the first one, thus we return [-2, 1, 2] as the result.\n   Example:\n\n   input: [\u22122, 1, 2, 0, \u22121, 2, 3, \u22125, 4]\n   output: [-2, 1, 2]\n*/\nvoid NO_INLINE longestIncreasingSubarray(std::vector<int> const& x, std::vector<int> &output) {\n    //return a null array when x is null\n    if(x.size()==0)\treturn ;\n\n    //initialize the variables\n    int longestStep = 1;\n    int start=0, end=0;\n\n    //Get the longestStep, and record its start index and end index\n    for (int i = 0; i < x.size(); i++) {\n        for (int j = i+1; j < x.size(); j++) {\n\t    if(x[i] < x[j])\t{\n\t\tint step = j-i+1;\n\t\tif(step > longestStep)\t{\n\t\t\tstart = i;\n\t\t\tend   = j;\n\t\t\tlongestStep = step;\n\t\t}\n\t    }\n\t    else break;\n        }\n    }\n    \n    //gather the subarray when longestStep > 1\n    for(int i=start; i <= end; i++)\t{\n        output.push_back(x[i]);\n    }\n}\n"
    },
    {
        "problem_type": "search",
        "language": "cpp",
        "name": "67_search_match_times",
        "parallelism_model": "serial",
        "prompt": "/* Return the total number of match times for `val` in vectors x and y.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: 1\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: 3\n*/\nint matchTimes(std::vector<int> const& x, std::vector<int> const& y, int val) {",
        "src_code": "#pragma once\n#include <vector>\n#include <algorithm>\n\n/* Return the total number of match times for `val` in vectors x and y.\n   Examples:\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: 1\n\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: 3\n*/\nint NO_INLINE matchTimes(std::vector<int> const& x, std::vector<int> const& y, int val) {\n   int xMatch = std::count(x.begin(), x.end(), val);\n   int yMatch = std::count(y.begin(), y.end(), val);\n\n   return xMatch+yMatch;\n}\n"
    },
    {
        "problem_type": "sort",
        "language": "cpp",
        "name": "68_sort_median",
        "parallelism_model": "serial",
        "prompt": "/* Given a vector x, please return its Median. The Median is the middle value in an ordered integer vector. If the size of the vector is even, there is no middle value, and the median is the mean of the two middle values.\n   \n   Example:\n\n   input: [2, 3, 4]\n   output: 3\n\n   input: [2, 3]\n   output: 2.5\n*/\nfloat median(std::vector<int> &x) {",
        "src_code": "#pragma once\n\n#include <algorithm>\n#include <vector>\n\n/* Given a vector x, please return its Median. The Median is the middle value in an ordered integer vector. If the size of the vector is even, there is no middle value, and the median is the mean of the two middle values.\n   \n   Example:\n\n   input: [2, 3, 4]\n   output: 3\n\n   input: [2, 3]\n   output: 2.5\n*/\n\nfloat NO_INLINE median(std::vector<int> &x) {\n    if(x.size()==0)\treturn 0;\n\n    std::sort(x.begin(), x.end());\n    if(x.size()%2==0)\treturn (x[x.size()/2] + x[x.size()/2-1])/2.0;\n    else  \t\treturn (float) (x[x.size()/2]);\n}\n"
    },
    {
        "problem_type": "sparse_la",
        "language": "cpp",
        "name": "69_sparse_la_sparse_lu_decomp",
        "parallelism_model": "serial",
        "prompt": "struct COOElement {\n   size_t row, column;\n   double value;\n};\n\n/* Factorize the sparse matrix A into A=LU where L is a lower triangular matrix and U is an upper triangular matrix.\n   A is a sparse NxN matrix stored in COO format.\n   Example:\n\n   input: A=[{0,0,4}, {0,1,3}, {1,0,6}, {1,1,3}]\n   output: L=[{0,0,1},{1,0,1.5}, {1,1,1}] U=[{0,0,4}, {0,1,3}, {1,1,-1.5}]\n*/\nvoid luFactorize(std::vector<COOElement> const& A, std::vector<double> &L, std::vector<double> &U, size_t N) {",
        "src_code": "#pragma once\n#include <vector>\n\n// defined in prompt\nstruct COOElement {\n   size_t row, column;\n   double value;\n};\n\n/* Factorize the sparse matrix A into A=LU where L is a lower triangular matrix and U is an upper triangular matrix.\n   A is a sparse NxN matrix stored in COO format. L and U are NxN matrices in row-major.\n   Example:\n\n   input: A=[{0,0,4}, {0,1,3}, {1,0,6}, {1,1,3}]\n   output: L=[{0,0,1},{1,0,1.5}, {1,1,1}] U=[{0,0,4}, {0,1,3}, {1,1,-1.5}]\n*/\nvoid NO_INLINE luFactorize(std::vector<COOElement> const& A, std::vector<double> &L, std::vector<double> &U, size_t N) {\n   std::vector<std::vector<double>> fullA(N, std::vector<double>(N, 0));\n   for (const auto& element : A) {\n      fullA[element.row][element.column] = element.value;\n   }\n   \n   // LU factorization algorithm\n   for (size_t i = 0; i < N; ++i) {\n      for (size_t j = 0; j < N; ++j) {\n         if (j >= i) {\n               U[i * N + j] = fullA[i][j];\n               for (size_t k = 0; k < i; ++k) {\n                  U[i * N + j] -= L[i * N + k] * U[k * N + j];\n               }\n         }\n         if (i > j) {\n               L[i * N + j] = fullA[i][j] / U[j * N + j];\n               for (size_t k = 0; k < j; ++k) {\n                  L[i * N + j] -= L[i * N + k] * U[k * N + j] / U[j * N + j];\n               }\n         }\n      }\n      L[i * N + i] = 1;\n   }\n}"
    },
    {
        "problem_type": "stencil",
        "language": "cpp",
        "name": "70_stencil_game_of_life",
        "parallelism_model": "serial",
        "prompt": "/* Simulate one generation of Game of Life on `input`. Store the results in `output`.\n   A cell is 1 if it is alive and 0 if it is dead.\n   If a live cell has fewer than 2 live neighbors then it dies.\n   If a live cell has 2 or 3 live neighbors then it lives on.\n   If a live cell has more than 3 live neighbords then it dies.\n   If a cell is dead and has exactly 3 live neighbors then it becomes alive.\n   `input` and `output` are NxN grids stored in row-major.\n   Example:\n\n   input:  [[0, 0, 0, 0, 0],\n\t\t\t\t\t  [0, 1, 0, 0, 0],\n            [0, 1, 1, 0, 0],\n            [0, 0, 1, 1, 0],\n            [0, 1, 0, 0, 0]]\n   output: [[0, 0, 0, 0, 0],\n\t\t\t\t\t  [0, 1, 1, 0, 0],\n            [0, 1, 0, 1, 0],\n            [0, 0, 0, 1, 0],\n            [0, 0, 1, 0, 0]]\n*/\nvoid gameOfLife(std::vector<int> const& input, std::vector<int> &output, size_t N) {",
        "src_code": "#pragma once\n#include <vector>\n\n/* Simulate one generation of Game of Life on `input`. Store the results in `output`.\n   A cell is 1 if it is alive and 0 if it is dead.\n   If a live cell has fewer than 2 live neighbors then it dies.\n   If a live cell has 2 or 3 live neighbors then it lives on.\n   If a live cell has more than 3 live neighbords then it dies.\n   If a cell is dead and has exactly 3 live neighbors then it becomes alive.\n   `input` and `output` are NxN grids stored in row-major.\n   Example:\n\n   input:  [[0, 0, 0, 0, 0],\n            [0, 1, 0, 0, 0],\n            [0, 1, 1, 0, 0],\n            [0, 0, 1, 1, 0],\n            [0, 1, 0, 0, 0]]\n   output: [[0, 0, 0, 0, 0],\n            [0, 1, 1, 0, 0],\n            [0, 1, 0, 1, 0],\n            [0, 0, 0, 1, 0],\n            [0, 0, 1, 0, 0]]\n*/\nvoid NO_INLINE gameOfLife(std::vector<int> const& input, std::vector<int> &output, size_t N) {\n    for (size_t i = 0; i < N; i++) {\n        for (size_t j = 0; j < N; j++) {\n            int sum = 0;\n            if (i > 0) {\n                sum += input[(i - 1) * N + j];\n            }\n            if (i < N - 1) {\n                sum += input[(i + 1) * N + j];\n            }\n            if (j > 0) {\n                sum += input[i * N + (j - 1)];\n            }\n            if (j < N - 1) {\n                sum += input[i * N + (j + 1)];\n            }\n            if (i > 0 && j > 0) {\n                sum += input[(i - 1) * N + (j - 1)];\n            }\n            if (i > 0 && j < N - 1) {\n                sum += input[(i - 1) * N + (j + 1)];\n            }\n            if (i < N - 1 && j > 0) {\n                sum += input[(i + 1) * N + (j - 1)];\n            }\n            if (i < N - 1 && j < N - 1) {\n                sum += input[(i + 1) * N + (j + 1)];\n            }\n            if (input[i * N + j] == 1) {\n                if (sum < 2) {\n                    output[i * N + j] = 0;\n                } else if (sum == 2 || sum == 3) {\n                    output[i * N + j] = 1;\n                } else {\n                    output[i * N + j] = 0;\n                }\n            } else {\n                if (sum == 3) {\n                    output[i * N + j] = 1;\n                } else {\n                    output[i * N + j] = 0;\n                }\n            }\n        }\n    }\n}\n"
    },
    {
        "problem_type": "transform",
        "language": "cpp",
        "name": "71_transform_map_function",
        "parallelism_model": "serial",
        "prompt": "bool isPowerOfTwo(int x) {\n\treturn (x > 0) && !(x & (x - 1));\n}\n\n/* Apply the isPowerOfTwo function to every value in x and store the results in mask.\n   Example:\n\n   input: [8, 0, 9, 7, 15, 64, 3]\n   output: [true, false, false, false, false, true, false]\n*/\nvoid mapPowersOfTwo(std::vector<int> const& x, std::vector<bool> &mask) {",
        "src_code": "#pragma once\nbool isPowerOfTwo(int x) {\n    return (x > 0) && !(x & (x - 1));\n}\n\n/* Apply the isPowerOfTwo function to every value in x and store the results in mask.\n   Example:\n   \n   input: [8, 0, 9, 7, 15, 64, 3]\n   output: [true, false, false, false, false, true, false]\n*/\nvoid NO_INLINE mapPowersOfTwo(std::vector<int> const& x, std::vector<bool> &mask) {\n    for (int i = 0; i < x.size(); i++) {\n        #if defined(USE_CUDA) || defined(USE_HIP)\n        mask[i] = isPowerOfTwoHOST(x[i]);\n        #else\n        mask[i] = isPowerOfTwo(x[i]);\n        #endif\n    }\n}"
    }
]