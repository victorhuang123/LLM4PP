{
    "17_graph_highest_degree": "#pragma once\n#include <algorithm>\n#include <vector>\n#include <limits>\n#include <omp.h>\n\n/* Compute the highest node degree in the undirected graph. The graph is defined in the adjacency matrix A.\n   A is an NxN adjacency matrix stored in row-major. A is undirected.\n   Example:\n\t input: [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [1, 1, 1, 0]]\n   output: 3\n*/\nint maxDegree(std::vector<int> const& A, size_t N) {\n   int highestDegree = 0;\n   #pragma omp parallel\n   {\n       int localMax = 0;\n       #pragma omp for\n       for (int i = 0; i < N; i += 1) {\n           int degree = 0;\n           for (int j = 0; j < N; j += 1) {\n               degree += A[i * N + j];\n           }\n           localMax = std::max(localMax, degree);\n       }\n       #pragma omp critical\n       highestDegree = std::max(highestDegree, localMax);\n   }\n   return highestDegree;\n}",
    "15_graph_edge_count": "#include <vector>\n#include <cstdint>\n#include <omp.h>\n\n/* Count the number of edges in the directed graph defined by the adjacency matrix A.\n   A is an NxN adjacency matrix stored in row-major.\n   Example:\n\t input: [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [1, 1, 1, 0]]\n   output: 3\n*/\nint edgeCount(std::vector<int> const& A, size_t N) {\n   int count = 0;\n   #pragma omp parallel for reduction(+:count)\n   for (int i = 0; i < N; i += 1) {\n      for (int j = 0; j < N; j += 1) {\n         count += A[i * N + j];\n      }\n   }\n   return count;\n}",
    "18_graph_count_components": "#include <vector>\n#include <stack>\n#include <limits>\n#include <omp.h>\n\nvoid dfs_helper(std::vector<int> const& A, int node, size_t N, std::vector<bool> &visited) {\n    std::stack<int> stack;\n    stack.push(node);\n    while (!stack.empty()) {\n        int current = stack.top();\n        stack.pop();\n        if (!visited[current]) {\n            visited[current] = true;\n            for (int i = 0; i < N; i += 1) {\n                if (A[current * N + i] == 1 && !visited[i]) {\n                    stack.push(i);\n                }\n            }\n        }\n    }\n}\n\nint componentCount(std::vector<int> const& A, size_t N) {\n    std::vector<bool> visited(N, false);\n    int count = 0;\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < N; i += 1) {\n        if (!visited[i]) {\n            dfs_helper(A, i, N, visited);\n            count += 1;\n        }\n    }\n    return count;\n}",
    "16_graph_largest_component": "#pragma once\n#include <vector>\n#include <limits>\n#include <omp.h>\n\nvoid dfs_helper(std::vector<int> const& A, int node, size_t N, std::vector<bool> &visited, int &count) {\n    visited[node] = true;\n    count += 1;\n    for (int i = 0; i < N; i++) {\n        if (A[node * N + i] == 1 && !visited[i]) {\n            dfs_helper(A, i, N, visited, count);\n        }\n    }\n}\n\n/* Return the number of vertices in the largest component of the graph defined by the adjacency matrix A.\n   A is an NxN adjacency matrix stored in row-major.\n   Example:\n\t input: [[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]\n   output: 2\n*/\nint largestComponent(std::vector<int> const& A, size_t N) {\n    std::vector<bool> visited(N, false);\n    int maxCount = 0;\n    #pragma omp parallel\n    {\n        int localMaxCount = 0;\n        std::vector<bool> localVisited(N, false);\n        #pragma omp for nowait\n        for (int i = 0; i < N; i++) {\n            if (!visited[i]) {\n                int count = 0;\n                dfs_helper(A, i, N, localVisited, count);\n                localMaxCount = std::max(localMaxCount, count);\n            }\n        }\n        #pragma omp critical\n        {\n            maxCount = std::max(maxCount, localMaxCount);\n            for (int j = 0; j < N; j++) {\n                visited[j] = visited[j] || localVisited[j];\n            }\n        }\n    }\n    return maxCount;\n}",
    "19_graph_shortest_path": "#include <vector>\n#include <queue>\n#include <limits>\n\n/* Return the length of the shortest path from source to dest in the undirected graph defined by the adjacency matrix A.\n   A is an NxN adjacency matrix stored in row-major. Assume the graph is connected. A is undirected.\n   Example:\n\t input: [[0, 1, 1, 0], [1, 0, 0, 1], [1, 0, 0, 1], [0, 1, 1, 0]], source=0, dest=3\n   output: 2\n*/\nint shortestPathLength(std::vector<int> const& A, size_t N, int source, int dest) {\n   std::vector<bool> visited(N, false);\n   std::queue<int> queue;\n   std::vector<int> distances(N, std::numeric_limits<int>::max());\n\n   visited[source] = true;\n   distances[source] = 0;\n   queue.push(source);\n\n   while (!queue.empty()) {\n      int current = queue.front();\n      queue.pop();\n\n      if (current == dest) {\n         return distances[current];\n      }\n\n      // Check all adjacent vertices\n      for (int i = 0; i < N; ++i) {\n         if (A[current * N + i] && !visited[i]) {\n            visited[i] = true;\n            distances[i] = distances[current] + 1;\n            queue.push(i);\n         }\n      }\n   }\n   return std::numeric_limits<int>::max();\n}",
    "21_histogram_bin_0-100": "#include <array>\n#include <vector>\n#include <algorithm>\n\n/* Vector x contains values between 0 and 100, inclusive. Count the number of\n   values in [0,10), [10, 20), [20, 30), ... and store the counts in `bins`.\n   Example:\n   input: [7, 32, 95, 12, 39, 32, 11, 71, 70, 66]\n   output: [1, 2, 0, 3, 0, 0, 1, 2, 0, 1]\n*/\nvoid binsBy10Count(const std::vector<double>& x, std::array<size_t, 10>& bins) {\n    std::fill(bins.begin(), bins.end(), 0); // Initialize bins to zero\n    for (const auto& value : x) {\n        bins[static_cast<size_t>(value / 10)] += 1;\n    }\n}",
    "23_histogram_first_letter_counts": "#include <array>\n#include <string>\n#include <vector>\n\n/* For each letter in the alphabet, count the number of strings in the vector s that start with that letter.\n   Assume all strings are in lower case. Store the output in `bins` array.\n   Example:\n   input: [\"dog\", \"cat\", \"xray\", \"cow\", \"code\", \"type\", \"flower\"]\n   output: [0, 0, 3, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]\n*/\nvoid firstLetterCounts(const std::vector<std::string> &s, std::array<size_t, 26> &bins) {\n    bins.fill(0);  // Initialize bins to zero\n    for (const auto &str : s) {\n        if (!str.empty()) {  // Check if the string is not empty\n            bins[str[0] - 'a']++;\n        }\n    }\n}",
    "20_histogram_pixel_histogram": "#pragma once\n#include <vector>\n#include <array>\n#include <omp.h>\n\n/* Count the number of pixels in image with each grayscale intensity.\n   The vector `image` is a grayscale image with values 0-255.\n   Store the results in `bins`.\n   Example:\n   \n   input: image=[2, 116, 201, 11, 92, 92, 201, 4, 2]\n   output: [0, 0, 2, 0, 1, ...]\n*/\nvoid pixelCounts(std::vector<int> const& image, std::array<size_t, 256> &bins) {\n    #pragma omp parallel\n    {\n        std::array<size_t, 256> local_bins = {0};\n        #pragma omp for nowait\n        for (int i = 0; i < image.size(); i += 1) {\n            local_bins[image[i]] += 1;\n        }\n        #pragma omp critical\n        {\n            for (int j = 0; j < 256; j++) {\n                bins[j] += local_bins[j];\n            }\n        }\n    }\n}",
    "24_histogram_count_quartile": "#include <array>\n#include <vector>\n#include <immintrin.h> // For AVX optimizations\n\n/* Count the number of doubles in the vector x that have a fractional part \n   in [0, 0.25), [0.25, 0.5), [0.5, 0.75), and [0.75, 1). Store the counts in `bins`.\n   Example:\n   input: [7.8, 4.2, 9.1, 7.6, 0.27, 1.5, 3.8]\n   output: [2, 1, 2, 2]\n*/\nvoid countQuartiles(std::vector<double> const& x, std::array<size_t, 4> &bins) {\n    std::fill(bins.begin(), bins.end(), 0); // Initialize bins to zero\n    size_t size = x.size();\n    size_t i = 0;\n\n    // Process 4 doubles at a time for vectorization\n    for (; i + 3 < size; i += 4) {\n        __m256d vals = _mm256_loadu_pd(&x[i]);\n        __m256d frac = _mm256_sub_pd(vals, _mm256_floor_pd(vals));\n\n        // Count in bins based on conditions\n        bins[0] += _mm256_movemask_pd(_mm256_cmp_pd(frac, _mm256_set1_pd(0.25), _CMP_LT_OQ));\n        bins[1] += _mm256_movemask_pd(_mm256_and_pd(_mm256_cmp_pd(frac, _mm256_set1_pd(0.5), _CMP_LT_OQ), _mm256_cmp_pd(frac, _mm256_set1_pd(0.25), _CMP_GE_OQ)));\n        bins[2] += _mm256_movemask_pd(_mm256_and_pd(_mm256_cmp_pd(frac, _mm256_set1_pd(0.75), _CMP_LT_OQ), _mm256_cmp_pd(frac, _mm256_set1_pd(0.5), _CMP_GE_OQ)));\n        bins[3] += _mm256_movemask_pd(_mm256_cmp_pd(frac, _mm256_set1_pd(0.75), _CMP_GE_OQ));\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        const double frac = x[i] - static_cast<int>(x[i]);\n        if (frac < 0.25) {\n            bins[0] += 1;\n        } else if (frac < 0.5) {\n            bins[1] += 1;\n        } else if (frac < 0.75) {\n            bins[2] += 1;\n        } else {\n            bins[3] += 1;\n        }\n    }\n}",
    "22_histogram_count_quadrants": "#pragma once\n#include <array>\n#include <vector>\n#include <execution>\n\nstruct Point {\n   double x, y;\n};\n\n/* Count the number of cartesian points in each quadrant. The vector points contains a list of `Point` objects.\n   Store the counts in `bins`.\n   Example:\n   input: [{x=1.5, y=0.1}, {x=-3, y=1.1}, {x=5, y=9}, {x=1.5, y=-1}, {x=3, y=-7}, {x=0.1, y=2}]\n   output: [3, 1, 0, 2]\n*/\nvoid countQuadrants(std::vector<Point> const& points, std::array<size_t, 4> &bins) {\n   bins.fill(0); // Initialize bins to zero\n   std::for_each(std::execution::par, points.begin(), points.end(), [&](const Point& point) {\n      if (point.x >= 0 && point.y >= 0) {\n            bins[0] += 1;\n      } else if (point.x < 0 && point.y >= 0) {\n            bins[1] += 1;\n      } else if (point.x < 0 && point.y < 0) {\n            bins[2] += 1;\n      } else if (point.x >= 0 && point.y < 0) {\n            bins[3] += 1;\n      }\n   });\n}",
    "34_scan_largest_contiguous_subarray_sum": "#pragma once\n#include <vector>\n#include <limits>\n\n/* Return the largest sum of any contiguous subarray in the vector x.\n   i.e. if x=[\u22122, 1, \u22123, 4, \u22121, 2, 1, \u22125, 4] then [4, \u22121, 2, 1] is the contiguous\n   subarray with the largest sum of 6.\n   Example:\n   input: [\u22122, 1, \u22123, 4, \u22121, 2, 1, \u22125, 4]\n   output: 6\n*/\nint maximumSubarray(std::vector<int> const& x) {\n    int largestSum = x[0];\n    int currSum = 0;\n    for (int i = 0; i < x.size(); i++) {\n        currSum = std::max(x[i], currSum + x[i]);\n        largestSum = std::max(largestSum, currSum);\n    }\n    return largestSum;\n}",
    "33_scan_reverse_prefix_sum": "#include <numeric>\n#include <vector>\n\n/* Compute the reverse prefix sum of the vector x into output.\n   Examples:\n   input: [1, 7, 4, 6, 6, 2]\n   output: [2, 8, 14, 18, 25, 26]\n   input: [3, 3, 7, 1, -2]\n   output: [-2, -1, 6, 9, 12]\n*/\nvoid reversePrefixSum(std::vector<int> const& x, std::vector<int> &output) {\n    int n = x.size();\n    output.resize(n);\n    output[n - 1] = x[n - 1];\n    for (int i = n - 2; i >= 0; i--) {\n        output[i] = output[i + 1] + x[i];\n    }\n}",
    "32_scan_sum_of_prefix_sum_array": "#include <numeric>\n#include <vector>\n\n/* Compute the prefix sum array of the vector x and return its sum.\n   Example:\n   input: [-7, 2, 1, 9, 4, 8]\n   output: 15\n*/\ndouble sumOfPrefixSum(std::vector<double> const& x) {\n    double sum = 0.0;\n    double currentSum = 0.0;\n    for (double val : x) {\n        currentSum += val;\n        sum += currentSum;\n    }\n    return sum;\n}",
    "31_scan_scan_with_min_function": "#include <vector>\n#include <limits>\n\n/* Replace the i-th element of the vector x with the minimum value from indices 0 through i.\n   Examples:\n   input: [8, 6, -1, 7, 3, 4, 4]\n   output: [8, 6, -1, -1, -1, -1, -1]\n   input: [5, 4, 6, 4, 3, 6, 1, 1]\n   output: [5, 4, 4, 4, 3, 3, 1, 1]\n*/\nvoid partialMinimums(std::vector<float> &x) {\n    float currentMin = std::numeric_limits<float>::max();\n    for (size_t i = 0; i < x.size(); ++i) {\n        currentMin = std::min(currentMin, x[i]);\n        x[i] = currentMin;\n    }\n}",
    "30_scan_prefix_sum": "#include <vector>\n#include <numeric>\n\n/* Compute the prefix sum of the vector x into output.\n   Example:\n   input: [1, 7, 4, 6, 6, 2]\n   output: [1, 8, 12, 18, 24, 26]\n*/\nvoid prefixSum(const std::vector<double>& x, std::vector<double>& output) {\n    double sum = 0;\n    for (size_t i = 0; i < x.size(); ++i) {\n        sum += x[i];\n        output[i] = sum;\n    }\n}",
    "59_transform_map_function": "#pragma once\n#include <vector>\n#include <bitset>\n\nbool isPowerOfTwo(int x) {\n    return (x > 0) && !(x & (x - 1));\n}\n/* Apply the isPowerOfTwo function to every value in x and store the results in mask.\n   Example:\n   \n   input: [8, 0, 9, 7, 15, 64, 3]\n   output: [true, false, false, false, false, true, false]\n*/\nvoid mapPowersOfTwo(const std::vector<int>& x, std::vector<bool>& mask) {\n    size_t size = x.size();\n    mask.resize(size);\n    #pragma omp parallel for\n    for (size_t i = 0; i < size; i++) {\n        mask[i] = isPowerOfTwo(x[i]);\n    }\n}",
    "55_transform_relu": "#include <vector>\n#include <algorithm>\n#include <execution>\n\n/* Compute the ReLU function on every element of x. Elements less than zero become zero,\n   while elements greater than zero stay the same.\n   Example:\n   input: [-1.8, 24.0, 1.2, 0.0, -5.1, -0.2, 4.5]\n   output: [0, 24.0, 1.2, 0, 0, 0, 4.5]\n*/\nvoid relu(std::vector<double> &x) {\n    std::transform(std::execution::par, x.begin(), x.end(), x.begin(), [](double v) {\n        return std::max(0.0, v);\n    });\n}",
    "56_transform_negate_odds": "#include <vector>\n#include <algorithm>\n\n/* In the vector x negate the odd values and divide the even values by 2.\n   Example:\n   input: [16, 11, 12, 14, 1, 0, 5]\n   output: [8, -11, 6, 7, -1, 0, -5]\n*/\nvoid negateOddsAndHalveEvens(std::vector<int> &x) {\n    #pragma omp parallel for\n    for(int i = 0; i < x.size(); ++i) {\n        x[i] = (x[i] % 2 == 0) ? (x[i] / 2) : (-x[i]);\n    }\n}",
    "57_transform_inverse_offset": "#include <vector>\n#include <algorithm>\n\n/* Replace every element of the vector x with 1-1/x.\n   Example:\n   input: [2, 4, 1, 12, -2]\n   output: [0.5, 0.75, 0, 0.91666666, 1.5]\n*/\nvoid oneMinusInverse(std::vector<double> &x) {\n    for (double &val : x) {\n        val = (val != 0) ? 1.0 - 1.0 / val : 1.0; // Handle division by zero gracefully\n    }\n}",
    "58_transform_squaring": "#include <vector>\n#include <execution>\n\n/* Replace every element of x with the square of its value.\n   Example:\n   input: [5, 1, 2, -4, 8]\n   output: [25, 1, 4, 16, 64]\n*/\nvoid squareEach(std::vector<int> &x) {\n    std::for_each(std::execution::par, x.begin(), x.end(), [](int &val) { val *= val; });\n}",
    "48_sparse_la_sparse_axpy": "#pragma once\n#include <vector>\n#include <algorithm>\n\nstruct Element {\n\tsize_t index;\n\tdouble value;\n};\n\n/* Compute z = alpha*x+y where x and y are sparse vectors. Store the result in z.\n   Example:\n   \n   input: x=[{5, 12}, {8, 3}, {12, -1}], y=[{3, 1}, {5, -2}, {7, 1}, {8, -3}], alpha=1\n   output: z=[{3, 1}, {5, 10}, {7, 1}, {12, -1}]\n*/\nvoid sparseAxpy(double alpha, std::vector<Element> const& x, std::vector<Element> const& y, std::vector<double> &z) {\n    size_t xi = 0, yi = 0;\n    size_t x_size = x.size();\n    size_t y_size = y.size();\n    while (xi < x_size && yi < y_size) {\n        if (x[xi].index < y[yi].index) {\n            z[x[xi].index] += alpha * x[xi].value;\n            ++xi;\n        } else if (x[xi].index > y[yi].index) {\n            z[y[yi].index] += y[yi].value;\n            ++yi;\n        } else {\n            z[x[xi].index] += alpha * x[xi].value + y[yi].value;\n            ++xi;\n            ++yi;\n        }\n    }\n    while (xi < x_size) {\n        z[x[xi].index] += alpha * x[xi].value;\n        ++xi;\n    }\n    while (yi < y_size) {\n        z[y[yi].index] += y[yi].value;\n        ++yi;\n    }\n}",
    "49_sparse_la_sparse_lu_decomp": "#pragma once\n#include <vector>\n#include <omp.h>\n\nstruct COOElement {\n   size_t row, column;\n   double value;\n};\n\n/* Factorize the sparse matrix A into A=LU where L is a lower triangular matrix and U is an upper triangular matrix.\n   A is a sparse NxN matrix stored in COO format. L and U are NxN matrices in row-major.\n   Example:\n   input: A=[{0,0,4}, {0,1,3}, {1,0,6}, {1,1,3}]\n   output: L=[{0,0,1},{1,0,1.5}, {1,1,1}] U=[{0,0,4}, {0,1,3}, {1,1,-1.5}]\n*/\nvoid luFactorize(std::vector<COOElement> const& A, std::vector<double> &L, std::vector<double> &U, size_t N) {\n   std::vector<std::vector<double>> fullA(N, std::vector<double>(N, 0));\n   for (const auto& element : A) {\n      fullA[element.row][element.column] = element.value;\n   }\n   \n   // LU factorization algorithm with parallelization\n   #pragma omp parallel for\n   for (size_t i = 0; i < N; ++i) {\n      for (size_t j = 0; j < N; ++j) {\n         if (j >= i) {\n               U[i * N + j] = fullA[i][j];\n               for (size_t k = 0; k < i; ++k) {\n                  U[i * N + j] -= L[i * N + k] * U[k * N + j];\n               }\n         }\n         if (i > j) {\n               L[i * N + j] = fullA[i][j] / U[j * N + j];\n               for (size_t k = 0; k < j; ++k) {\n                  L[i * N + j] -= L[i * N + k] * U[k * N + j] / U[j * N + j];\n               }\n         }\n      }\n      L[i * N + i] = 1;\n   }\n}",
    "46_sparse_la_spmm": "#pragma once\n#include <vector>\n#include <unordered_map>\n\nstruct COOElement {\n   size_t row, column;\n   double value;\n};\n\n/* Compute the matrix multiplication Y=AX. A is a sparse MxK matrix in COO format.\n   X is a sparse KxN matrix in COO format. Y is a dense MxN matrix in row-major.\n   Example:\n   input: A=[{0,0,-2}, {0,1,1}, {1,1,-1}] X=[{0,1,2}, {1,0,-1}]\n   output: Y=[{-1,-4}, {1,0}]\n*/\nvoid spmm(std::vector<COOElement> const& A, std::vector<COOElement> const& X, std::vector<double>& Y, size_t M, size_t K, size_t N) {\n   Y.assign(M * N, 0);\n   std::unordered_map<size_t, double> x_map;\n   \n   for (const auto& x : X) {\n       x_map[x.row * N + x.column] = x.value;\n   }\n   \n   for (const auto& a : A) {\n       auto iter = x_map.find(a.column);\n       if (iter != x_map.end()) {\n           Y[a.row * N + iter->first % N] += a.value * iter->second;\n       }\n   }\n}",
    "45_sparse_la_sparse_solve": "#pragma once\n#include <vector>\n#include <algorithm>\n\nstruct COOElement {\n   size_t row, column;\n   double value;\n};\n\n/* Solve the sparse linear system Ax=b for x.\n   A is a sparse NxN matrix in COO format. x and b are dense vectors with N elements.\n   Example:\n   \n   input: A=[{0,0,1}, {0,1,1}, {1,1,-2}] b=[1,4]\n   output: x=[3,-2]\n*/\nvoid solveLinearSystem(std::vector<COOElement> const& A, std::vector<double> const& b, std::vector<double> &x, size_t N) {\n   std::vector<double> matrix[N * N];   \n   std::vector<double> b_copy = b;\n   // Fill the matrix with the values from A\n   for (const auto& element : A) {\n      matrix[element.row * N + element.column] = element.value;\n   }\n   // Initialize x with the size N\n   x.assign(N, 0.0);\n   // Perform Gaussian elimination\n   for (size_t i = 0; i < N; ++i) {\n      // Find pivot\n      double maxEl = std::abs(matrix[i * N + i]);\n      size_t maxRow = i;\n      for (size_t k = i + 1; k < N; ++k) {\n         if (std::abs(matrix[k * N + i]) > maxEl) {\n               maxEl = std::abs(matrix[k * N + i]);\n               maxRow = k;\n         }\n      }\n      // Swap maximum row with current row (column by column)\n      for (size_t k = i; k < N; ++k) {\n         std::swap(matrix[maxRow * N + k], matrix[i * N + k]);\n      }\n      std::swap(b_copy[maxRow], b_copy[i]);\n      // Make all rows below this one 0 in the current column\n      for (size_t k = i + 1; k < N; ++k) {\n         double c = -matrix[k * N + i] / matrix[i * N + i];\n         for (size_t j = i; j < N; ++j) {\n            if (i == j) {\n               matrix[k * N + j] = 0;\n            } else {\n               matrix[k * N + j] += c * matrix[i * N + j];\n            }\n         }\n         b_copy[k] += c * b_copy[i];\n      }\n   }\n   // Solve equation Ax=b for an upper triangular matrix A\n   for (int i = N - 1; i >= 0; --i) {\n      x[i] = b_copy[i] / matrix[i * N + i];\n      for (int k = i - 1; k >= 0; --k) {\n         b_copy[k] -= matrix[k * N + i] * x[i];\n      }\n   }\n}",
    "47_sparse_la_spmv": "#include <vector>\n#include <omp.h>\n\nstruct COOElement {\n   size_t row, column;\n   double value;\n};\n\n/* Compute y = alpha*A*x + beta*y where alpha and beta are scalars, x and y are vectors,\n   and A is a sparse matrix stored in COO format.\n   x and y are length N and A is M x N.\n   Example:\n   input: alpha=0.5 beta=1.0 A=[{0,1,3}, {1,0,-1}] x=[-4, 2] y=[-1,1]\n   output: y=[2, 3]\n*/\nvoid spmv(double alpha, std::vector<COOElement> const& A, std::vector<double> const& x, double beta, std::vector<double>& y, size_t M, size_t N) {\n   #pragma omp parallel for\n   for (size_t i = 0; i < y.size(); ++i) {\n      y[i] *= beta;\n   }\n   \n   #pragma omp parallel for\n   for (const auto& a_ij : A) {\n      if (a_ij.row < M && a_ij.column < N) {\n         #pragma omp atomic\n         y[a_ij.row] += alpha * a_ij.value * x[a_ij.column];\n      }\n   }\n}",
    "25_reduce_xor": "#include <vector>\n#include <numeric>\n\n/* Return the logical XOR reduction of the vector of bools x.\n   Example:\n   input: [false, false, false, true]\n   output: true\n*/\nbool reduceLogicalXOR(std::vector<bool> const& x) {\n    return std::accumulate(x.begin(), x.end(), false, std::bit_xor<bool>());\n}",
    "27_reduce_average": "#include <vector>\n#include <numeric>\n\n/* Return the average of the vector x.\n   Examples:\n   input: [1, 8, 4, 5, 1]\n   output: 3.8\n   input: [2, 2, 2, 3]\n   output: 2.25\n*/\ndouble average(const std::vector<double>& x) {\n    const auto total = std::accumulate(x.begin(), x.end(), 0.0);\n    return total / static_cast<double>(x.size());\n}",
    "28_reduce_smallest_odd_number": "#pragma once\n#include <vector>\n#include <limits>\n\n/* Return the value of the smallest odd number in the vector x.\n   Examples:\n   input: [7, 9, 5, 2, 8, 16, 4, 1]\n   output: 1\n   input: [8, 36, 7, 2, 11]\n   output: 7\n*/\nint smallestOdd(std::vector<int> const& x) {\n    int minOdd = std::numeric_limits<int>::max();\n    for (const auto &value : x) {\n        if (value % 2 == 1 && value < minOdd) {\n            minOdd = value;\n        }\n    }\n    return minOdd;\n}",
    "29_reduce_sum_of_min_of_pairs": "#include <vector>\n#include <algorithm>\n#include <numeric>\n\n/* Return the sum of the minimum value at each index of vectors x and y for all indices.\n   i.e. sum = min(x_0, y_0) + min(x_1, y_1) + min(x_2, y_2) + ...\n   Example:\n   input: x=[3, 4, 0, 2, 3], y=[2, 5, 3, 1, 7]\n   output: 10\n*/\ndouble sumOfMinimumElements(const std::vector<double>& x, const std::vector<double>& y) {\n    double total = 0;\n    size_t size = std::min(x.size(), y.size());\n    for (size_t i = 0; i < size; ++i) {\n        total += std::min(x[i], y[i]);\n    }\n    return total;\n}",
    "26_reduce_product_of_inverses": "#pragma once\n#include <vector>\n#include <numeric>\n#include <execution>\n\n/* Return the product of the vector x with every odd indexed element inverted.\n   i.e. x_0 * 1/x_1 * x_2 * 1/x_3 * x_4 ...\n   Example:\n   input: [4, 2, 10, 4, 5]\n   output: 25\n*/\ndouble productWithInverses(std::vector<double> const& x) {\n    double result = 1.0;\n    for (size_t i = 0; i < x.size(); i++) {\n        if (i % 2 == 0) {\n            result *= x[i];\n        } else {\n            result /= x[i];\n        }\n    }\n    return result;\n}",
    "08_fft_split_fft": "#include <vector>\n#include <cmath>\n#include <complex>\n\n/* Compute the fourier transform of x. Store real part of results in r and imaginary in i.\n   Example:\n   input: [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]\n   output: r: [4, 1, 0, 1, 0, 1, 0, 1] i: [0, -2.41421, 0, -0.414214, 0, 0.414214, 0, 2.41421]\n*/\nvoid fft(std::vector<std::complex<double>> const& x, std::vector<double> &r, std::vector<double> &i) {\n\tstd::vector<std::complex<double>> x_copy = x;\n\tunsigned int N = x_copy.size();\n\tdouble thetaT = 2.0 * M_PI / N;\n\tfor (unsigned int s = 1; s < N; s <<= 1) {\n\t\tfor (unsigned int j = 0; j < N; j += s << 1) {\n\t\t\tfor (unsigned int k = 0; k < s; k++) {\n\t\t\t\tstd::complex<double> t = std::polar(1.0, -thetaT * k) * x_copy[j + k + s];\n\t\t\t\tx_copy[j + k + s] = x_copy[j + k] - t;\n\t\t\t\tx_copy[j + k] += t;\n\t\t\t}\n\t\t}\n\t}\n   // split into real and imaginary parts\n   for (size_t j = 0; j < x_copy.size(); j += 1) {\n      r[j] = x_copy[j].real();\n      i[j] = x_copy[j].imag();\n   }\n}",
    "06_fft_dft": "#pragma once\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <omp.h>\n\n\n#if !defined(M_PI)\n#define M_PI 3.14159265358979323846\n#endif\n/* Compute the discrete fourier transform of x. Store the result in output.\n   Example:\n   input: [1, 4, 9, 16]\n   output: [30+0i, -8-12i, -10-0i, -8+12i]\n*/\nvoid dft(std::vector<double> const& x, std::vector<std::complex<double>>& output) {\n    int N = x.size();\n    output.resize(N, std::complex<double>(0, 0)); // Resize the output vector and initialize with 0\n\n    #pragma omp parallel for \n    for (int k = 0; k < N; k++) { // For each output element\n        std::complex<double> sum(0, 0);\n        for (int n = 0; n < N; n++) { // For each input element\n            double angle = 2 * M_PI * n * k / N;\n            std::complex<double> c(std::cos(angle), -std::sin(angle)); // Euler's formula\n            sum += x[n] * c;\n        }\n        output[k] = sum;\n    }\n}",
    "09_fft_fft_out_of_place": "#include <vector>\n#include <complex>\n#include <cmath>\n#include <iostream>\n\n#if !defined(M_PI)\n#define M_PI 3.14159265358979323846\n#endif\n\n/* Compute the fourier transform of x. Store the result in output.\n   Example:\n   input: [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]\n   output: [{4,0}, {1,-2.41421}, {0,0}, {1,-0.414214}, {0,0}, {1,0.414214}, {0,0}, {1,2.41421}]\n*/\nvoid fft(std::vector<std::complex<double>> const& x, std::vector<std::complex<double>> &output) {\n    output.resize(x.size()); // Make sure to resize output\n    int N = x.size(); // Get number of points\n    for (int k = 0; k < N; ++k) {\n        output[k] = {0, 0};\n        for (int n = 0; n < N; ++n) {\n            double angle = 2 * M_PI * n * k / N;\n            output[k] += x[n] * std::complex<double>(cos(angle), -sin(angle));\n        }\n    }\n}\n",
    "07_fft_fft_conjugate": "#pragma once\n#include <vector>\n#include <complex>\n#include <cmath>\n\nvoid fftCooleyTookey(std::vector<std::complex<double>>& x);\n\nvoid fftConjugate(std::vector<std::complex<double>>& x) {\n    const size_t N = x.size();\n    if (N <= 1) return;\n    // divide\n    std::vector<std::complex<double>> even(N / 2), odd(N / 2);\n    for (size_t i = 0; i < N / 2; ++i) {\n        even[i] = x[i * 2];\n        odd[i] = x[i * 2 + 1];\n    }\n    // conquer\n    fftCooleyTookey(even);\n    fftCooleyTookey(odd);\n    // combine\n    for (size_t k = 0; k < N / 2; ++k) {\n        std::complex<double> t = std::polar(1.0, -2 * M_PI * k / N) * odd[k];\n        x[k] = even[k] + t;\n        x[k + N / 2] = even[k] - t;\n    }\n}",
    "05_fft_inverse_fft": "#pragma once\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <algorithm>\n\n#if !defined(M_PI)\n#define M_PI 3.14159265358979323846\n#endif\nvoid fft_helper(std::vector<std::complex<double>> &x) {\n   unsigned int N = x.size(), k = N, n;\n   double thetaT = 2 * M_PI / N;\n   std::complex<double> phiT(std::cos(thetaT), -std::sin(thetaT)), T;\n   while (k > 1) {\n       n = k;\n       k >>= 1;\n       T = 1.0L;\n       for (unsigned int l = 0; l < k; l++) {\n           for (unsigned int a = l; a < N; a += n) {\n               unsigned int b = a + k;\n               std::complex<double> t = x[a] - x[b];\n               x[a] += x[b];\n               x[b] = t * T;\n           }\n           T *= phiT;\n       }\n   }\n   unsigned int m = (unsigned int)std::log2(N);\n   for (unsigned int a = 0; a < N; a++) {\n       unsigned int b = a;\n       b = (((b & 0xaaaaaaaa) >> 1) | ((b & 0x55555555) << 1));\n       b = (((b & 0xcccccccc) >> 2) | ((b & 0x33333333) << 2));\n       b = (((b & 0xf0f0f0f0) >> 4) | ((b & 0x0f0f0f0f) << 4));\n       b = (((b & 0xff00ff00) >> 8) | ((b & 0x00ff00ff) << 8));\n       b = ((b >> 16) | (b << 16)) >> (32 - m);\n       if (b > a) {\n           std::complex<double> t = x[a];\n           x[a] = x[b];\n           x[b] = t;\n       }\n   }\n}\n\nvoid ifft(std::vector<std::complex<double>> &x) {\n   std::transform(x.begin(), x.end(), x.begin(), [](auto const& val) { return std::conj(val); });\n   fft_helper(x);\n   std::transform(x.begin(), x.end(), x.begin(), [](auto const& val) { return std::conj(val); });\n   std::transform(x.begin(), x.end(), x.begin(), [&](std::complex<double> c) { return c / static_cast<double>(x.size()); });\n}",
    "13_geometry_closest_pair_2d": "#pragma once\n#include <vector>\n#include <limits>\n#include <cmath>\n\nstruct Point {\n\tdouble x, y;\n};\n\n/* Return the distance between the closest two points in the vector points.\n   Example:\n   input: [{2, 3}, {12, 30}, {40, 50}, {5, 1}, {12, 10}, {3, 4}]\n   output: 1.41421\n*/\ndouble closestPair(std::vector<Point> const& points) {\n    // The polygon needs to have at least two points\n    if (points.size() < 2) {\n        return 0;\n    }\n    double minDist = std::numeric_limits<double>::max();\n    for (size_t i = 0; i < points.size(); i++) {\n        for (size_t j = i + 1; j < points.size(); j++) {\n            double dist = std::hypot(points[j].x - points[i].x, points[j].y - points[i].y);\n            minDist = std::min(minDist, dist);\n        }\n    }\n    return minDist;\n}",
    "12_geometry_smallest_triangle": "#pragma once\n#include <vector>\n#include <limits>\n#include <algorithm>\n\nstruct Point {\n\tdouble x, y;\n};\n\ndouble triangleArea(Point const& A, Point const& B, Point const& C) {\n    return 0.5 * std::abs( A.x * (B.y - C.y) + B.x * (C.y - A.y) + C.x * (A.y - B.y) );\n}\n\n/* Return the area of the smallest triangle that can be formed by any 3 points.\n   Example:\n   input: [{0, 10}, {5, 5}, {1,0}, {-1, 1}, {-10, 0}]\n   output: 5.5\n*/\ndouble smallestArea(std::vector<Point> const& points) {\n    // The polygon needs to have at least three points\n    if (points.size() < 3) {\n        return 0;\n    }\n    double minArea = std::numeric_limits<double>::max();\n    for (size_t i = 0; i < points.size(); ++i) {\n        for (size_t j = i + 1; j < points.size(); ++j) {\n            for (size_t k = j + 1; k < points.size(); ++k) {\n                double area = triangleArea(points[i], points[j], points[k]);\n                minArea = std::min(minArea, area);\n            }\n        }\n    }\n    return minArea;\n}",
    "14_geometry_closest_pair_1d": "#pragma once\n#include <vector>\n#include <limits>\n#include <algorithm>\n\n/* Return the distance between the closest two elements in the vector x.\n   Example:\n   input: [7, 3, 9, 12, 31, 1]\n   output: 2\n*/\ndouble closestPair(std::vector<double> const& x) {\n    // The vector needs to have at least two elements\n    if (x.size() < 2) {\n        return 0;\n    }\n    std::vector<double> sorted_x = x;\n    std::sort(sorted_x.begin(), sorted_x.end());\n    double minDist = std::numeric_limits<double>::max();\n    for (size_t i = 1; i < sorted_x.size(); i++) {\n        minDist = std::min(minDist, sorted_x[i] - sorted_x[i - 1]);\n    }\n    return minDist;\n}",
    "11_geometry_convex_hull_perimeter": "#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n\nstruct Point {\n\tdouble x, y;\n};\n\ndouble distance(Point const& p1, Point const& p2) {\n\treturn std::hypot(p2.x - p1.x, p2.y - p1.y);\n}\n\n/* Return the perimeter of the smallest convex polygon that contains all the points in the vector points.\n   Example:\n   input: [{0, 3}, {1, 1}, {2, 2}, {4, 4}, {0, 0}, {1, 2}, {3, 1}, {3, 3}]\n   output: 13.4477\n*/\ndouble convexHullPerimeter(std::vector<Point> const& points) {\n    // The polygon needs to have at least three points\n    if (points.size() < 3)   {\n        return 0;\n    }\n    std::vector<Point> pointsSorted = points;\n    std::sort(pointsSorted.begin(), pointsSorted.end(), [](Point const& a, Point const& b) {\n        return a.x < b.x || (a.x == b.x && a.y < b.y);\n    });\n    auto CrossProduct = [](const Point& a, const Point& b, const Point& c) {\n        return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n    };\n    std::vector<Point> upperHull, lowerHull;\n    upperHull.push_back(pointsSorted[0]);\n    upperHull.push_back(pointsSorted[1]);\n    for (size_t i = 2; i < pointsSorted.size(); i++) {\n        while (upperHull.size() > 1 && CrossProduct(upperHull[upperHull.size() - 2], upperHull.back(), pointsSorted[i]) <= 0) {\n            upperHull.pop_back();\n        }\n        upperHull.push_back(pointsSorted[i]);\n    }\n    lowerHull.push_back(pointsSorted.back());\n    for (size_t i = pointsSorted.size() - 2; i < pointsSorted.size(); i--) {\n        while (lowerHull.size() > 1 && CrossProduct(lowerHull[lowerHull.size() - 2], lowerHull.back(), pointsSorted[i]) <= 0) {\n            lowerHull.pop_back();\n        }\n        lowerHull.push_back(pointsSorted[i]);\n    }\n    upperHull.pop_back(); // Remove the last point because it is repeated\n    double perimeter = 0;\n    for (const auto& point : upperHull) {\n        perimeter += distance(point, upperHull.front());\n    }\n    for (const auto& point : lowerHull) {\n        perimeter += distance(point, lowerHull.front());\n    }\n    return perimeter;\n}",
    "10_geometry_convex_hull": "#pragma once\n#include <vector>\n#include <algorithm>\n#include <iterator>\n\nstruct Point {\n   double x, y;\n};\n\n/* Find the set of points that defined the smallest convex polygon that contains all the points in the vector points. Store the result in `hull`.\n   Example:\n   input: [{0, 3}, {1, 1}, {2, 2}, {4, 4}, {0, 0}, {1, 2}, {3, 1}, {3, 3}]\n   output: [{0, 3}, {4, 4}, {3, 1}, {0, 0}]\n*/\nvoid convexHull(std::vector<Point> const& points, std::vector<Point> &hull) {\n    // The polygon needs to have at least three points\n    if (points.size() < 3)   {\n        hull = points;\n        return;\n    }\n    std::vector<Point> pointsSorted = points;\n    std::sort(pointsSorted.begin(), pointsSorted.end(), [](Point const& a, Point const& b) {\n        return a.x < b.x || (a.x == b.x && a.y < b.y);\n    });\n    auto CrossProduct = [](Point const& a, Point const& b, Point const& c) {\n        return (c.x - a.x) * (b.y - a.y) - (c.y - a.y) * (b.x - a.x) > 0;\n    };\n    std::vector<Point> upperHull, lowerHull;\n\n    // Build upper hull\n    for (const auto& point : pointsSorted) {\n        while (upperHull.size() >= 2 && !CrossProduct(upperHull[upperHull.size() - 2], upperHull.back(), point)) {\n            upperHull.pop_back();\n        }\n        upperHull.push_back(point);\n    }\n\n    // Build lower hull\n    for (size_t i = pointsSorted.size(); i > 0; --i) {\n        const auto& point = pointsSorted[i - 1];\n        while (lowerHull.size() >= 2 && !CrossProduct(lowerHull[lowerHull.size() - 2], lowerHull.back(), point)) {\n            lowerHull.pop_back();\n        }\n        lowerHull.push_back(point);\n    }\n\n    // Remove last point of each half because it is repeated at the beginning of the other half\n    upperHull.pop_back(); lowerHull.pop_back();\n\n    // Combine the two halves\n    upperHull.insert(upperHull.end(), lowerHull.begin(), lowerHull.end());\n    hull = std::move(upperHull);\n}",
    "52_stencil_1d_jacobi_3-point_stencil": "#pragma omp parallel\n#include <vector>\n\n\n\n/* Compute one iteration of a 3-point 1D jacobi stencil on `input`. Store the results in `output`.\n   Each element of `input` will be averaged with its two neighbors and stored in the corresponding element of `output`.\n   i.e. output[i] = (input[i-1]+input[i]+input[i+1])/3\n   Replace with 0 when reading past the boundaries of `input`.\n   Example:\n   input: [9, -6, -1, 2, 3]\n   output: [1, 2/3, -5/3, 4/3, 5/3]\n*/\nvoid jacobi1D(std::vector<double> const& input, std::vector<double> &output) {\n    #pragma omp for\n    for (size_t i = 0; i < input.size(); i++) {\n        double sum = input[i];\n        if (i > 0) {\n            sum += input[i - 1];\n        }\n        if (i < input.size() - 1) {\n            sum += input[i + 1];\n        }\n        output[i] = sum / 3.0;\n    }\n}",
    "51_stencil_edge_kernel": "#pragma once\n#include <vector>\n#include <algorithm>\n\nconst int edgeKernel[3][3] = {{-1, -1, -1}, {-1, 8, -1}, {-1, -1, -1}};\n\n/* Convolve the edge kernel with a grayscale image. Each pixel will be replaced with\n   the dot product of itself and its neighbors with the edge kernel.\n   Use a value of 0 for pixels outside the image's boundaries and clip outputs between 0 and 255.\n   imageIn and imageOut are NxN grayscale images stored in row-major.\n   Store the output of the computation in imageOut.\n*/\nvoid convolveKernel(const std::vector<int>& imageIn, std::vector<int>& imageOut, size_t N) {\n    std::fill(imageOut.begin(), imageOut.end(), 0); // Initialize output to zero\n    for (size_t i = 0; i < N; i++) {\n        for (size_t j = 0; j < N; j++) {\n            int sum = 0;\n            for (int k = -1; k <= 1; k++) {\n                for (int l = -1; l <= 1; l++) {\n                    int x = i + k;\n                    int y = j + l;\n                    if (x >= 0 && x < N && y >= 0 && y < N) {\n                        sum += imageIn[x * N + y] * edgeKernel[k + 1][l + 1];\n                    }\n                }\n            }\n            imageOut[i * N + j] = std::clamp(sum, 0, 255); // Clipping the output value\n        }\n    }\n}",
    "50_stencil_xor_kernel": "#include <vector>\n#include <omp.h>\n\n/* Set every cell's value to 1 if it has exactly one neighbor that's a 1. Otherwise set it to 0.\n   Note that we only consider neighbors and not input_{i,j} when computing output_{i,j}.\n   input and output are NxN grids of ints in row-major.\n   Example:\n   input: [[0, 1, 1, 0],\n           [1, 0, 0, 0],\n           [0, 0, 0, 0],\n           [0, 1, 0, 0]\n   output: [[0, 0, 1, 1],\n            [1, 0, 0, 1],\n            [0, 0, 1, 0],\n            [1, 0, 1, 0]]\n*/\nvoid cellsXOR(const std::vector<int>& input, std::vector<int>& output, size_t N) {\n    #pragma omp parallel for collapse(2) \n    for (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int count = 0;\n            if (i > 0 && input[(i-1)*N + j] == 1) ++count;\n            if (i < N-1 && input[(i+1)*N + j] == 1) ++count;\n            if (j > 0 && input[i*N + j-1] == 1) ++count;\n            if (j < N-1 && input[i*N + j+1] == 1) ++count;\n            output[i*N + j] = (count == 1) ? 1 : 0;\n        }\n    }\n}",
    "53_stencil_2d_jacobi_5-point_stencil": "#pragma once\n#include <vector>\n#include <omp.h>\n\n/* Compute one iteration of a 5-point 2D jacobi stencil on `input`. Store the results in `output`.\n   Each element of `input` will be averaged with its four neighbors and stored in the corresponding element of `output`.\n   i.e. output_{i,j} = (input_{i,j-1} + input_{i,j+1} + input_{i-1,j} + input_{i+1,j} + input_{i,j})/5\n   Replace with 0 when reading past the boundaries of `input`.\n   `input` and `output` are NxN grids stored in row-major.\n   Example:\n   input: [[3, 4, 1], [0, 1, 7], [5, 3, 2]]\n   output: [[1.4, 1.8, 2.4],[1.8, 3, 2.2], [1.6, 2.2, 2.4]]\n*/\nvoid jacobi2D(std::vector<double> const& input, std::vector<double> &output, size_t N) {\n    #pragma omp parallel for collapse(2)\n    for (size_t i = 0; i < N; i++) {\n        for (size_t j = 0; j < N; j++) {\n            double sum = 0;\n            int count = 0;\n            if (i > 0) {\n                sum += input[(i - 1) * N + j];\n                count++;\n            }\n            if (i < N - 1) {\n                sum += input[(i + 1) * N + j];\n                count++;\n            }\n            if (j > 0) {\n                sum += input[i * N + (j - 1)];\n                count++;\n            }\n            if (j < N - 1) {\n                sum += input[i * N + (j + 1)];\n                count++;\n            }\n            sum += input[i * N + j];\n            count++;\n            output[i * N + j] = sum / count;\n        }\n    }\n}",
    "54_stencil_game_of_life": "#pragma once\n#include <vector>\n\n\n\n/* Simulate one generation of Game of Life on `input`. Store the results in `output`.\n   A cell is 1 if it is alive and 0 if it is dead.\n   If a live cell has fewer than 2 live neighbors then it dies.\n   If a live cell has 2 or 3 live neighbors then it lives on.\n   If a live cell has more than 3 live neighbors then it dies.\n   If a cell is dead and has exactly 3 live neighbors then it becomes alive.\n   `input` and `output` are NxN grids stored in row-major.\n   Example:\n   input:  [[0, 0, 0, 0, 0],\n            [0, 1, 0, 0, 0],\n            [0, 1, 1, 0, 0],\n            [0, 0, 1, 1, 0],\n            [0, 1, 0, 0, 0]]\n   output: [[0, 0, 0, 0, 0],\n            [0, 1, 1, 0, 0],\n            [0, 1, 0, 1, 0],\n            [0, 0, 0, 1, 0],\n            [0, 0, 1, 0, 0]]\n*/\nvoid gameOfLife(std::vector<int> const& input, std::vector<int> &output, size_t N) {\n    for (size_t i = 0; i < N; i++) {\n        for (size_t j = 0; j < N; j++) {\n            int sum = 0;\n            sum += (i > 0 ? input[(i - 1) * N + j] : 0);\n            sum += (i < N - 1 ? input[(i + 1) * N + j] : 0);\n            sum += (j > 0 ? input[i * N + (j - 1)] : 0);\n            sum += (j < N - 1 ? input[i * N + (j + 1)] : 0);\n            sum += (i > 0 && j > 0 ? input[(i - 1) * N + (j - 1)] : 0);\n            sum += (i > 0 && j < N - 1 ? input[(i - 1) * N + (j + 1)] : 0);\n            sum += (i < N - 1 && j > 0 ? input[(i + 1) * N + (j - 1)] : 0);\n            sum += (i < N - 1 && j < N - 1 ? input[(i + 1) * N + (j + 1)] : 0);\n            output[i * N + j] = (input[i * N + j] == 1 && (sum == 2 || sum == 3)) || (input[i * N + j] == 0 && sum == 3) ? 1 : 0;\n        }\n    }\n}",
    "03_dense_la_axpy": "#pragma once\n#include <vector>\n#include <omp.h>\n\n\n/* Compute z = alpha*x+y where x and y are vectors. Store the result in z.\n   Example:\n   \n   input: x=[1, -5, 2, 9] y=[0, 4, 1, -1] alpha=2\n   output: z=[2, -6, 5, 17]\n*/\nvoid axpy(double alpha, std::vector<double> const& x, std::vector<double> const& y, std::vector<double> &z) {\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); i++) {\n        z[i] = alpha * x[i] + y[i];\n    }\n}",
    "02_dense_la_gemm": "#pragma once\n#include <vector>\n#include <omp.h>\n\n/* Multiply the matrix A by the matrix B. Store the results in the matrix C.\n   A is an MxK matrix, B is a KxN matrix, and C is a MxN matrix. The matrices are stored in row-major.\n   Example:\n   input: A=[[1, -1, 2], [0, -2, 1]] B=[[4, 1], [-1, 0], [2, 2]]\n   output: C=[[9, 5], [4, 2]]\n*/\nvoid gemm(std::vector<double> const& A, std::vector<double> const& B, std::vector<double> &C, size_t M, size_t K, size_t N) {\n    #pragma omp parallel for\n    for (size_t i = 0; i < M; i++) {\n        for (size_t j = 0; j < N; j++) {\n            C[i*N + j] = 0; // Initialize C[i][j] to 0 before accumulating\n        }\n        for (size_t k = 0; k < K; k++) {\n            for (size_t j = 0; j < N; j++) {\n                C[i*N + j] += A[i*K + k] * B[k*N + j];\n            }\n        }\n    }\n}",
    "04_dense_la_gemv": "#include <vector>\n\n/* Multiply the matrix A by the vector x. Store the results in the vector y.\n   A is an MxN matrix stored in row-major, x has N elements, and y has M elements.\n   Example:\n   input: A=[[1, -1, 2], [0, -3, 1]] x=[2, 1, 0]\n   output: y=[1, -3]\n*/\nvoid gemv(std::vector<double> const& A, std::vector<double> const& x, std::vector<double> &y, size_t M, size_t N) {\n    for (size_t i = 0; i < M; ++i) {\n        y[i] = 0;\n        for (size_t j = 0; j < N; ++j) {\n            y[i] += A[i * N + j] * x[j];\n        }\n    }\n}",
    "01_dense_la_solve": "#pragma once\n#include <vector>\n#include <stdexcept>\n#include <iostream>\n\n/* Solve the linear system Ax=b for x.\n   A is an NxN matrix in row-major. x and b have N elements.\n   Example:\n   input: A=[[1,4,2], [1,2,3], [2,1,3]] b=[11, 11, 13]\n   output: x=[3, 1, 2]\n*/\nvoid solveLinearSystem(std::vector<double> const& A, std::vector<double> const& b, std::vector<double> &x, size_t N) {\n    // Check if input dimensions are valid\n    if (A.size() != N * N || b.size() != N) {\n        throw std::invalid_argument(\"Invalid dimensions for matrix A or vector b.\");\n    }\n   \n    // Gaussian elimination with partial pivoting\n    std::vector<double> A_copy = A;\n    std::vector<double> b_copy = b;\n\n    for (size_t i = 0; i < N; i++) {\n        // Find the pivot element with maximum value\n        size_t pivotIndex = i;\n        for (size_t j = i + 1; j < N; j++) {\n            if (std::abs(A_copy[j * N + i]) > std::abs(A_copy[pivotIndex * N + i])) {\n                pivotIndex = j;\n            }\n        }\n\n        // Swap the pivot row with the current row\n        if (pivotIndex != i) {\n            for (size_t k = 0; k < N; k++) {\n                std::swap(A_copy[i * N + k], A_copy[pivotIndex * N + k]);\n            }\n            std::swap(b_copy[i], b_copy[pivotIndex]);\n        }\n\n        // Check for singular matrix\n        if (std::abs(A_copy[i * N + i]) < 1e-12) {\n            throw std::runtime_error(\"Singular matrix detected.\");\n        }\n\n        // Eliminate elements below the pivot\n        for (size_t j = i + 1; j < N; j++) {\n            double factor = A_copy[j * N + i] / A_copy[i * N + i];\n            for (size_t k = i; k < N; k++) {\n                A_copy[j * N + k] -= factor * A_copy[i * N + k];\n            }\n            b_copy[j] -= factor * b_copy[i];\n        }\n    }\n\n    // Back substitution\n    for (int i = N - 1; i >= 0; --i) {\n        double sum = 0;\n        for (size_t j = i + 1; j < N; j++) {\n            sum += A_copy[i * N + j] * x[j];\n        }\n        x[i] = (b_copy[i] - sum) / A_copy[i * N + i];\n    }\n}",
    "00_dense_la_lu_decomp": "#pragma once\n#include <vector>\n\n\n/* Factorize the matrix A into A=LU where L is a lower triangular matrix and U is an upper triangular matrix.\n   Store the results for L and U into the original matrix A. \n   A is an NxN matrix stored in row-major.\n   Example:\n   input: [[4, 3], [6, 3]]\n   output: [[4, 3], [1.5, -1.5]]\n*/\nvoid luFactorize(std::vector<double> &A, size_t N) {\n    for (size_t k = 0; k < N; ++k) {\n        double pivot = A[k * N + k];\n        for (size_t i = k + 1; i < N; ++i) {\n            double factor = A[i * N + k] / pivot;\n            A[i * N + k] = factor;\n            \n            for (size_t j = k + 1; j < N; ++j) {\n                A[i * N + j] -= factor * A[k * N + j];\n            }\n        }\n    }\n}",
    "42_sort_sorted_ranks": "#pragma once\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <iterator>\n\n\n\n/* For each value in the vector x compute its index in the sorted vector.\n   Store the results in `ranks`.\n   Examples:\n   input: [3.1, 2.8, 9.1, 0.4, 3.14]\n   output: [2, 1, 4, 0, 3]\n   input: [100, 7.6, 16.1, 18, 7.6]\n   output: [4, 0, 1, 2, 3]\n*/\nvoid ranks(const std::vector<float>& x, std::vector<size_t>& ranks_) {\n    size_t n = x.size();\n    std::vector<size_t> indices(n);\n    std::iota(indices.begin(), indices.end(), 0);\n    std::sort(indices.begin(), indices.end(), [&x](size_t i1, size_t i2) {\n        return x[i1] < x[i2];\n    });\n    for (size_t i = 0; i < n; ++i) {\n        ranks_[indices[i]] = i;\n    }\n}",
    "43_sort_sort_an_array_of_structs_by_key": "#pragma once\n#include <vector>\n#include <algorithm>\n\nstruct Result {\n   int startTime, duration;\n   float value;\n};\n\n/* Sort vector of Result structs by start time in ascending order.\n   Example:\n   input: [{startTime=8, duration=4, value=-1.22}, {startTime=2, duration=10, value=1.0}, {startTime=10, duration=3, value=0.0}]\n   output: [{startTime=2, duration=10, value=1.0}, {startTime=8, duration=4, value=-1.22}, {startTime=10, duration=3, value=0.0}]\n*/\nvoid sortByStartTime(std::vector<Result> &results) {\n   std::sort(results.begin(), results.end(), [](const Result &a, const Result &b) {\n      return a.startTime < b.startTime;\n   });\n}",
    "40_sort_sort_an_array_of_complex_numbers_by_magnitude": "#pragma once\n#include <complex>\n#include <vector>\n#include <algorithm>\n\n/* Sort the vector x of complex numbers by their magnitude in ascending order.\n   Example:\n   \n   input: [3.0-1.0i, 4.5+2.1i, 0.0-1.0i, 1.0-0.0i, 0.5+0.5i]\n   output: [0.5+0.5i, 0.0-1.0i, 1.0-0.0i, 3.0-1.0i, 4.5+2.1i]\n*/\nvoid sortComplexByMagnitude(std::vector<std::complex<double>> &x) {\n   std::sort(x.begin(), x.end(), [](const std::complex<double> &a, const std::complex<double> &b) {\n      return std::norm(a) < std::norm(b);\n   });\n}",
    "44_sort_sort_non-zero_elements": "#pragma once\n#include <algorithm>\n#include <vector>\n\nvoid sortIgnoreZero(std::vector<int> &x) {\n    std::vector<int> nonZeroElements;\n    nonZeroElements.reserve(x.size()); // Reserve memory to avoid multiple allocations\n    for (int num : x) {\n        if (num != 0) {\n            nonZeroElements.push_back(num);\n        }\n    }\n    std::sort(nonZeroElements.begin(), nonZeroElements.end());\n    size_t nonZeroIndex = 0;\n    for (int &num : x) {\n        if (num != 0) {\n            num = nonZeroElements[nonZeroIndex++];\n        }\n    }\n}",
    "41_sort_k-th_smallest_element": "#include <algorithm>\n#include <vector>\n#include <queue>\n\n/* Find the k-th smallest element of the vector x using a min-heap.\n   Example:\n   input: x=[1, 7, 6, 0, 2, 2, 10, 6], k=4\n   output: 6\n*/\nint findKthSmallest(std::vector<int> const& x, int k) {\n    std::priority_queue<int, std::vector<int>, std::greater<int>> minHeap;\n    for (int num : x) {\n        minHeap.push(num);\n    }\n    for (int i = 1; i < k; ++i) {\n        minHeap.pop();\n    }\n    return minHeap.top();\n}",
    "37_search_find_the_closest_number_to_pi": "#pragma once\n#include <vector>\n#include <cmath>\n#include <limits>\n\n/* Return the index of the value in the vector x that is closest to the math constant PI.\n   Use M_PI for the value of PI.\n   Example:\n   input: [9.18, 3.05, 7.24, 11.3, -166.49, 2.1]\n   output: 1\n*/\nsize_t findClosestToPi(const std::vector<double>& x) {\n    size_t index = 0;\n    double minDiff = std::numeric_limits<double>::max();\n    for (size_t i = 0; i < x.size(); ++i) {\n        double diff = std::abs(x[i] - M_PI);\n        if (diff < minDiff) {\n            minDiff = diff;\n            index = i;\n        }\n    }\n    return index;\n}",
    "39_search_xor_contains": "#pragma once\n#include <vector>\n#include <algorithm>\n#include <unordered_set>\n\n\n/* Return true if `val` is only in one of vectors x or y.\n   Return false if it is in both or neither.\n   Examples:\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7\n   output: true\n   input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1\n   output: false\n*/\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {\n    std::unordered_set<int> setX(all(x));\n    std::unordered_set<int> setY(all(y));\n    return (setX.count(val) > 0) ^ (setY.count(val) > 0);\n}",
    "38_search_find_the_first_even_number": "#include <vector>\n\n/*\n * Return the index of the first even number in the vector x.\n * Examples:\n * input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n * output: 6\n * input: [3, 8, 9, 9, 3, 4, 8, 6]\n * output: 1\n */\nsize_t findFirstEven(std::vector<int> const& x) {\n    for (size_t i = 0; i < x.size(); ++i) {\n        if ((x[i] & 1) == 0) { // Use bitwise & for even check\n            return i;\n        }\n    }\n    return x.size();\n}",
    "35_search_search_for_last_struct_by_key": "#pragma once\n#include <vector>\n#include <string>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\n/* Return the index of the last Book item in the vector books where Book.pages is less than 100.\n   Example:\n   input: [{title=\\\"Green Eggs and Ham\\\", pages=72}, {title=\\\"gulliver's travels\\\", pages=362}, {title=\\\"Stories of Your Life\\\", pages=54}, {title=\\\"Hamilton\\\", pages=818}]\n   output: 2\n*/\nsize_t findLastShortBook(const std::vector<Book>& books) {\n    size_t lastIndex = books.size();\n    while (lastIndex > 0 && books[lastIndex - 1].pages >= 100) {\n        --lastIndex;\n    }\n    return lastIndex > 0 ? lastIndex - 1 : books.size();\n}",
    "36_search_check_if_array_contains_value": "#pragma once\n#include <vector>\n#include <unordered_set>\n\n/* Return true if the vector x contains the value `target`. Return false otherwise.\n   Examples:\n   \n   input: x=[1, 8, 2, 6, 4, 6], target=3\n   output: false\n   input: x=[1, 8, 2, 6, 4, 6], target=8\n   output: true\n*/\nbool contains(std::vector<int> const& x, int target) {\n    std::unordered_set<int> set(x.begin(), x.end());\n    return set.find(target) != set.end();\n}"
}